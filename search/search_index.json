{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pipda A framework for data piping in python Inspired by siuba , dfply , plydata and dplython , but with simple yet powerful APIs to mimic the dplyr and tidyr packages in python API | Change Log | Playground Installation pip install -U pipda Usage Checkout datar for more detailed usages. Verbs Verbs are functions next to the piping sign ( >> ) receiving the data directly. import pandas as pd from pipda import ( register_verb , register_func , register_operator , evaluate_expr , Operator , Symbolic , Context ) f = Symbolic () df = pd . DataFrame ({ 'x' : [ 0 , 1 , 2 , 3 ], 'y' : [ 'zero' , 'one' , 'two' , 'three' ] }) df # x y # 0 0 zero # 1 1 one # 2 2 two # 3 3 three @register_verb ( pd . DataFrame ) def head ( data , n = 5 ): return data . head ( n ) df >> head ( 2 ) # x y # 0 0 zero # 1 1 one @register_verb ( pd . DataFrame , context = Context . EVAL ) def mutate ( data , ** kwargs ): data = data . copy () for key , val in kwargs . items (): data [ key ] = val return data df >> mutate ( z = 1 ) # x y z # 0 0 zero 1 # 1 1 one 1 # 2 2 two 1 # 3 3 three 1 df >> mutate ( z = f . x ) # x y z # 0 0 zero 0 # 1 1 one 1 # 2 2 two 2 # 3 3 three 3 # Verbs that don't compile f.a to data, but just the column name @register_verb ( pd . DataFrame , context = Context . SELECT ) def select ( data , * columns ): return data . loc [:, columns ] # f.x won't be compiled as df.x but just 'x' df >> mutate ( z = 2 * f . x ) >> select ( f . x , f . z ) # x z # 0 0 0 # 1 1 2 # 2 2 4 # 3 3 6 # Compile the args inside the verb @register_verb ( pd . DataFrame , context = Context . PENDING ) def mutate_existing ( data , column , value ): column = evaluate_expr ( column , data , Context . SELECT ) value = evaluate_expr ( value , data , Context . EVAL ) data = data . copy () data [ column ] = value return data # First f.x compiled as column name, and second as Series data df2 = df >> mutate_existing ( f . x , 10 * f . x ) df2 # x y z # 0 0 zero 0 # 1 10 one 2 # 2 20 two 4 # 3 30 three 6 # Evaluate the arguments by yourself @register_verb ( pd . DataFrame , context = Context . PENDING ) def mutate_existing2 ( data , column , value ): column = evaluate_expr ( column , data , Context . SELECT ) value = evaluate_expr ( value , df2 , Context . EVAL ) data = data . copy () data [ column ] = value return data df >> mutate_existing2 ( f . x , 2 * f . x ) # x y # 0 0 zero # 1 20 one # 2 40 two # 3 60 three # register for multiple types @register_verb ( int ) def add ( data , other ): return data + other # add is actually a singledispatch generic function @add . register ( float ) def _ ( data , other ): return data * other 1 >> add ( 1 ) # 2 1.1 >> add ( 1.0 ) # 1.1 # As it's a singledispatch generic function, we can do it for multiple types # with the same logic @register_verb ( context = Context . EVAL ) def mul ( data , other ): raise NotImplementedError # not invalid until types registered @mul . register ( int ) @mul . register ( float ) # or you could do @mul.register((int, float)) # context is also supported def _ ( data , other ): return data * other 3 >> mul ( 2 ) # 6 3.2 >> mul ( 2 ) # 6.4 Functions used in verb arguments @register_func ( context = Context . EVAL ) def if_else ( data , cond , true , false ): cond . loc [ cond . isin ([ True ]), ] = true cond . loc [ cond . isin ([ False ]), ] = false return cond # The function is then also a singledispatch generic function df >> mutate ( z = if_else ( f . x > 1 , 20 , 10 )) # x y z # 0 0 zero 10 # 1 1 one 10 # 2 2 two 20 # 3 3 three 20 # function without data argument @register_func ( None ) def length ( strings ): return [ len ( s ) for s in strings ] df >> mutate ( z = length ( f . y )) # x y z # 0 0 zero 4 # 1 1 one 3 # 2 2 two 3 # 3 3 three 5 # register existing functions from numpy import vectorize len = register_func ( None , context = Context . EVAL , func = vectorize ( len )) # original function still works print ( len ( 'abc' )) df >> mutate ( z = len ( f . y )) # 3 # x y z # 0 0 zero 4 # 1 1 one 3 # 2 2 two 3 # 3 3 three 5 Operators You may also redefine the behavior of the operators @register_operator class MyOperators ( Operator ): def xor ( self , a , b ): \"\"\"Inteprete X ^ Y as pow(X, Y).\"\"\" return a ** b df >> mutate ( z = f . x ^ 2 ) # x y z # 0 0 zero 0 # 1 1 one 1 # 2 2 two 4 # 3 3 three 9 Context The context defines how a reference ( f.A , f['A'] , f.A.B is evaluated) from pipda import ContextBase class MyContext ( ContextBase ): name = 'my' def getattr ( self , parent , ref ): # double it to distinguish getattr return getattr ( parent , ref ) def getitem ( self , parent , ref ): return parent [ ref ] * 2 @property def ref ( self ): # how we evaluate the ref in f[ref] return self @register_verb ( context = MyContext ()) def mutate_mycontext ( data , ** kwargs ): for key , val in kwargs . items (): data [ key ] = val return data df >> mutate_mycontext ( z = f . x + f [ 'x' ]) # x y z # 0 0 zero 0 # 1 1 one 3 # 2 2 two 6 # 3 3 three 9 # when ref in f[ref] is also needed to be evaluated df = df >> mutate ( zero = 0 , one = 1 , two = 2 , three = 3 ) df # x y z zero one two three # 0 0 zero 0 0 1 2 3 # 1 1 one 3 0 1 2 3 # 2 2 two 6 0 1 2 3 # 3 3 three 9 0 1 2 3 df >> mutate_mycontext ( m = f [ f . y ][: 1 ] . values [ 0 ]) # f.y returns ['zero', 'one', 'two', 'three'] # f[f.y] gets [[0, 2, 4, 6], [0, 2, 4, 6], [0, 2, 4, 6], [0, 2, 4, 6]] # f[f.y][:1].values gets [[0, 4, 8, 16]] # f[f.y][:1].values[0] returns [0, 8, 16, 32] # Notes that each subscription ([]) will double the values # x y z zero one two three m # 0 0 zero 0 0 1 2 3 0 # 1 1 one 3 0 1 2 3 8 # 2 2 two 6 0 1 2 3 16 # 3 3 three 9 0 1 2 3 24 Calling rules Verb calling rules data >> verb(...) \\ [PIPING_VERB]\\ First argument should not be passed, using the data data >> other_verb(verb(...)) \\ other_verb(data, verb(...)) \\ registered_func(verb(...)) \\ [PIPING]\\ Try using the first argument to evaluate (FastEvalVerb), if first argument is data. Otherwise, if it is Expression object, works as a non-data Function. verb(...) \\ Called independently. The verb will be called regularly anyway. The first argument will be used as data to evaluate the arguments if there are any Expression objects verb(...) with DataEnv\\ First argument should not be passed in, will use the DataEnv's data to evaluate the arguments Data function calling rules Functions that require first argument as data argument. data >> verb(func(...)) or verb(data, func(...)) \\ First argument is not used. Will use data func(...) \\ Called independently. The function will be called regularly anyway. Similar as Verb calling rule, but first argument will not be used for evaluation func(...) with DataEnv\\ First argument not used, passed implicitly with DataEnv. Non-data function calling rules: data >> verb(func(...)) or verb(data, func(...)) \\ Return a Function object waiting for evaluation func(...) \\ Called regularly anyway func(...) with DataEnv \\ Evaluate with DataEnv. For example: mean(f.x) Caveats You have to use and_ and or_ for bitwise and/or ( & / | ) operators, as and and or are python keywords. Limitations: Any limitations apply to executing to detect the AST node will apply to pipda . It may not work in some circumstances where other AST magics apply. What if source code is not available? executing does not work in the case where source code is not available, as there is no way to detect the AST node to check how the functions (verbs, data functions, non-data functions) are called, either they are called as a piping verb ( data >> verb(...) ), or they are called as an argument of a verb ( data >> verb(func(...)) ) or even they are called independently/regularly. In such a case, you can set the option ( options.assume_all_piping=True ( pipda v0.4.4+ )) to assume that all registered functions are called in piping mode, so that you can do data >> verb(...) without any changes. You can also use this option to enhance the performance by skipping detection of the calling environment. Use another piping sign from pipda import register_piping register_piping ( '^' ) # register verbs and functions df ^ verb1 ( ... ) ^ verb2 ( ... ) Allowed signs are: + , - , * , @ , / , // , % , ** , << , >> , & , ^ and | . Note that to use the new piping sign, you have to register the verbs after the new piping sign being registered. The context The context is only applied to the DirectReference objects or unary operators, like -f.A , +f.A , ~f.A , f.A , f['A'] , [f.A, f.B] , etc. Any other Expression wrapping those objects or other operators getting involved will turn the context to Context.EVAL How it works The verbs data %>% verb ( arg1 , ... , key1 = kwarg1 , ... ) The above is a typical dplyr / tidyr data piping syntax. The counterpart R syntax we expect is: data >> verb ( arg1 , ... , key1 = kwarg1 , ... ) To implement that, we need to defer the execution of the verb by turning it into a Verb object, which holds all information of the function to be executed later. The Verb object won't be executed until the data is piped in. It all thanks to the executing package to let us determine the ast nodes where the function is called. So that we are able to determine whether the function is called in a piping mode. If an argument is referring to a column of the data and the column will be involved in the later computation, the it also needs to be deferred. For example, with dplyr in R : data %>% mutate ( z = a ) is trying add a column named z with the data from column a . In python, we want to do the same with: data >> mutate ( z = f . a ) where f.a is a Reference object that carries the column information without fetching the data while python sees it immmediately. Here the trick is f . Like other packages, we introduced the Symbolic object, which will connect the parts in the argument and make the whole argument an Expression object. This object is holding the execution information, which we could use later when the piping is detected. The functions Then what if we want to use some functions in the arguments of the verb ? For example: data >> select ( starts_with ( 'a' )) to select the columns with names start with 'a' . No doubt that we need to defer the execution of the function, too. The trick is that we let the function return a Function object as well, and evaluate it as the argument of the verb. The operators pipda also opens oppotunities to change the behavior of the operators in verb/function arguments. This allows us to mimic something like this: data >> select ( - f . a ) # select all columns but `a` To do that, we turn it into an Operator object. Just like a Verb or a Function object, the execution is deferred. By default, the operators we used are from the python standard library operator . operator.neg in the above example. You can also define you own by subclassing the Operator class, and then register it to replace the default one by decorating it with register_operator .","title":"Home"},{"location":"#pipda","text":"A framework for data piping in python Inspired by siuba , dfply , plydata and dplython , but with simple yet powerful APIs to mimic the dplyr and tidyr packages in python API | Change Log | Playground","title":"pipda"},{"location":"#installation","text":"pip install -U pipda","title":"Installation"},{"location":"#usage","text":"Checkout datar for more detailed usages.","title":"Usage"},{"location":"#verbs","text":"Verbs are functions next to the piping sign ( >> ) receiving the data directly. import pandas as pd from pipda import ( register_verb , register_func , register_operator , evaluate_expr , Operator , Symbolic , Context ) f = Symbolic () df = pd . DataFrame ({ 'x' : [ 0 , 1 , 2 , 3 ], 'y' : [ 'zero' , 'one' , 'two' , 'three' ] }) df # x y # 0 0 zero # 1 1 one # 2 2 two # 3 3 three @register_verb ( pd . DataFrame ) def head ( data , n = 5 ): return data . head ( n ) df >> head ( 2 ) # x y # 0 0 zero # 1 1 one @register_verb ( pd . DataFrame , context = Context . EVAL ) def mutate ( data , ** kwargs ): data = data . copy () for key , val in kwargs . items (): data [ key ] = val return data df >> mutate ( z = 1 ) # x y z # 0 0 zero 1 # 1 1 one 1 # 2 2 two 1 # 3 3 three 1 df >> mutate ( z = f . x ) # x y z # 0 0 zero 0 # 1 1 one 1 # 2 2 two 2 # 3 3 three 3 # Verbs that don't compile f.a to data, but just the column name @register_verb ( pd . DataFrame , context = Context . SELECT ) def select ( data , * columns ): return data . loc [:, columns ] # f.x won't be compiled as df.x but just 'x' df >> mutate ( z = 2 * f . x ) >> select ( f . x , f . z ) # x z # 0 0 0 # 1 1 2 # 2 2 4 # 3 3 6 # Compile the args inside the verb @register_verb ( pd . DataFrame , context = Context . PENDING ) def mutate_existing ( data , column , value ): column = evaluate_expr ( column , data , Context . SELECT ) value = evaluate_expr ( value , data , Context . EVAL ) data = data . copy () data [ column ] = value return data # First f.x compiled as column name, and second as Series data df2 = df >> mutate_existing ( f . x , 10 * f . x ) df2 # x y z # 0 0 zero 0 # 1 10 one 2 # 2 20 two 4 # 3 30 three 6 # Evaluate the arguments by yourself @register_verb ( pd . DataFrame , context = Context . PENDING ) def mutate_existing2 ( data , column , value ): column = evaluate_expr ( column , data , Context . SELECT ) value = evaluate_expr ( value , df2 , Context . EVAL ) data = data . copy () data [ column ] = value return data df >> mutate_existing2 ( f . x , 2 * f . x ) # x y # 0 0 zero # 1 20 one # 2 40 two # 3 60 three # register for multiple types @register_verb ( int ) def add ( data , other ): return data + other # add is actually a singledispatch generic function @add . register ( float ) def _ ( data , other ): return data * other 1 >> add ( 1 ) # 2 1.1 >> add ( 1.0 ) # 1.1 # As it's a singledispatch generic function, we can do it for multiple types # with the same logic @register_verb ( context = Context . EVAL ) def mul ( data , other ): raise NotImplementedError # not invalid until types registered @mul . register ( int ) @mul . register ( float ) # or you could do @mul.register((int, float)) # context is also supported def _ ( data , other ): return data * other 3 >> mul ( 2 ) # 6 3.2 >> mul ( 2 ) # 6.4","title":"Verbs"},{"location":"#functions-used-in-verb-arguments","text":"@register_func ( context = Context . EVAL ) def if_else ( data , cond , true , false ): cond . loc [ cond . isin ([ True ]), ] = true cond . loc [ cond . isin ([ False ]), ] = false return cond # The function is then also a singledispatch generic function df >> mutate ( z = if_else ( f . x > 1 , 20 , 10 )) # x y z # 0 0 zero 10 # 1 1 one 10 # 2 2 two 20 # 3 3 three 20 # function without data argument @register_func ( None ) def length ( strings ): return [ len ( s ) for s in strings ] df >> mutate ( z = length ( f . y )) # x y z # 0 0 zero 4 # 1 1 one 3 # 2 2 two 3 # 3 3 three 5 # register existing functions from numpy import vectorize len = register_func ( None , context = Context . EVAL , func = vectorize ( len )) # original function still works print ( len ( 'abc' )) df >> mutate ( z = len ( f . y )) # 3 # x y z # 0 0 zero 4 # 1 1 one 3 # 2 2 two 3 # 3 3 three 5","title":"Functions used in verb arguments"},{"location":"#operators","text":"You may also redefine the behavior of the operators @register_operator class MyOperators ( Operator ): def xor ( self , a , b ): \"\"\"Inteprete X ^ Y as pow(X, Y).\"\"\" return a ** b df >> mutate ( z = f . x ^ 2 ) # x y z # 0 0 zero 0 # 1 1 one 1 # 2 2 two 4 # 3 3 three 9","title":"Operators"},{"location":"#context","text":"The context defines how a reference ( f.A , f['A'] , f.A.B is evaluated) from pipda import ContextBase class MyContext ( ContextBase ): name = 'my' def getattr ( self , parent , ref ): # double it to distinguish getattr return getattr ( parent , ref ) def getitem ( self , parent , ref ): return parent [ ref ] * 2 @property def ref ( self ): # how we evaluate the ref in f[ref] return self @register_verb ( context = MyContext ()) def mutate_mycontext ( data , ** kwargs ): for key , val in kwargs . items (): data [ key ] = val return data df >> mutate_mycontext ( z = f . x + f [ 'x' ]) # x y z # 0 0 zero 0 # 1 1 one 3 # 2 2 two 6 # 3 3 three 9 # when ref in f[ref] is also needed to be evaluated df = df >> mutate ( zero = 0 , one = 1 , two = 2 , three = 3 ) df # x y z zero one two three # 0 0 zero 0 0 1 2 3 # 1 1 one 3 0 1 2 3 # 2 2 two 6 0 1 2 3 # 3 3 three 9 0 1 2 3 df >> mutate_mycontext ( m = f [ f . y ][: 1 ] . values [ 0 ]) # f.y returns ['zero', 'one', 'two', 'three'] # f[f.y] gets [[0, 2, 4, 6], [0, 2, 4, 6], [0, 2, 4, 6], [0, 2, 4, 6]] # f[f.y][:1].values gets [[0, 4, 8, 16]] # f[f.y][:1].values[0] returns [0, 8, 16, 32] # Notes that each subscription ([]) will double the values # x y z zero one two three m # 0 0 zero 0 0 1 2 3 0 # 1 1 one 3 0 1 2 3 8 # 2 2 two 6 0 1 2 3 16 # 3 3 three 9 0 1 2 3 24","title":"Context"},{"location":"#calling-rules","text":"","title":"Calling rules"},{"location":"#verb-calling-rules","text":"data >> verb(...) \\ [PIPING_VERB]\\ First argument should not be passed, using the data data >> other_verb(verb(...)) \\ other_verb(data, verb(...)) \\ registered_func(verb(...)) \\ [PIPING]\\ Try using the first argument to evaluate (FastEvalVerb), if first argument is data. Otherwise, if it is Expression object, works as a non-data Function. verb(...) \\ Called independently. The verb will be called regularly anyway. The first argument will be used as data to evaluate the arguments if there are any Expression objects verb(...) with DataEnv\\ First argument should not be passed in, will use the DataEnv's data to evaluate the arguments","title":"Verb calling rules"},{"location":"#data-function-calling-rules","text":"Functions that require first argument as data argument. data >> verb(func(...)) or verb(data, func(...)) \\ First argument is not used. Will use data func(...) \\ Called independently. The function will be called regularly anyway. Similar as Verb calling rule, but first argument will not be used for evaluation func(...) with DataEnv\\ First argument not used, passed implicitly with DataEnv.","title":"Data function calling rules"},{"location":"#non-data-function-calling-rules","text":"data >> verb(func(...)) or verb(data, func(...)) \\ Return a Function object waiting for evaluation func(...) \\ Called regularly anyway func(...) with DataEnv \\ Evaluate with DataEnv. For example: mean(f.x)","title":"Non-data function calling rules:"},{"location":"#caveats","text":"You have to use and_ and or_ for bitwise and/or ( & / | ) operators, as and and or are python keywords. Limitations: Any limitations apply to executing to detect the AST node will apply to pipda . It may not work in some circumstances where other AST magics apply. What if source code is not available? executing does not work in the case where source code is not available, as there is no way to detect the AST node to check how the functions (verbs, data functions, non-data functions) are called, either they are called as a piping verb ( data >> verb(...) ), or they are called as an argument of a verb ( data >> verb(func(...)) ) or even they are called independently/regularly. In such a case, you can set the option ( options.assume_all_piping=True ( pipda v0.4.4+ )) to assume that all registered functions are called in piping mode, so that you can do data >> verb(...) without any changes. You can also use this option to enhance the performance by skipping detection of the calling environment. Use another piping sign from pipda import register_piping register_piping ( '^' ) # register verbs and functions df ^ verb1 ( ... ) ^ verb2 ( ... ) Allowed signs are: + , - , * , @ , / , // , % , ** , << , >> , & , ^ and | . Note that to use the new piping sign, you have to register the verbs after the new piping sign being registered. The context The context is only applied to the DirectReference objects or unary operators, like -f.A , +f.A , ~f.A , f.A , f['A'] , [f.A, f.B] , etc. Any other Expression wrapping those objects or other operators getting involved will turn the context to Context.EVAL","title":"Caveats"},{"location":"#how-it-works","text":"","title":"How it works"},{"location":"#the-verbs","text":"data %>% verb ( arg1 , ... , key1 = kwarg1 , ... ) The above is a typical dplyr / tidyr data piping syntax. The counterpart R syntax we expect is: data >> verb ( arg1 , ... , key1 = kwarg1 , ... ) To implement that, we need to defer the execution of the verb by turning it into a Verb object, which holds all information of the function to be executed later. The Verb object won't be executed until the data is piped in. It all thanks to the executing package to let us determine the ast nodes where the function is called. So that we are able to determine whether the function is called in a piping mode. If an argument is referring to a column of the data and the column will be involved in the later computation, the it also needs to be deferred. For example, with dplyr in R : data %>% mutate ( z = a ) is trying add a column named z with the data from column a . In python, we want to do the same with: data >> mutate ( z = f . a ) where f.a is a Reference object that carries the column information without fetching the data while python sees it immmediately. Here the trick is f . Like other packages, we introduced the Symbolic object, which will connect the parts in the argument and make the whole argument an Expression object. This object is holding the execution information, which we could use later when the piping is detected.","title":"The verbs"},{"location":"#the-functions","text":"Then what if we want to use some functions in the arguments of the verb ? For example: data >> select ( starts_with ( 'a' )) to select the columns with names start with 'a' . No doubt that we need to defer the execution of the function, too. The trick is that we let the function return a Function object as well, and evaluate it as the argument of the verb.","title":"The functions"},{"location":"#the-operators","text":"pipda also opens oppotunities to change the behavior of the operators in verb/function arguments. This allows us to mimic something like this: data >> select ( - f . a ) # select all columns but `a` To do that, we turn it into an Operator object. Just like a Verb or a Function object, the execution is deferred. By default, the operators we used are from the python standard library operator . operator.neg in the above example. You can also define you own by subclassing the Operator class, and then register it to replace the default one by decorating it with register_operator .","title":"The operators"},{"location":"changelog/","text":"0.4.5 Add CallingEnvs.REGULAR 0.4.4 Add options and options_context . Move warn_astnode_failure to options Add assume_all_piping mode 0.4.3 Avoid raising exception for varname() to get the name of Symbolic object. 0.4.2 Make Function property private thus accessiable to getattr() (otherwise returns an Expression object) Give better repr for Function when func is an Expression object. 0.4.1 Fix getattr() failure for operator-connected expressions (pwwang/datar#38) 0.4.0 Improve calling rules for verbs, data functions and non-data functions Remove evaluate_args() and evaluate_kwargs() , use evaluate_expr() instead 0.3.0 Added: - Add a better regular calling strategy and warn for ambiguity - Support #11 Breaking changes: - Rename register_piping_sign to register_piping 0.2.9 Avoid func of Function object to be re-evaluated (fixing datar#14) 0.2.8 Add is_direct argument to context getitem/getattr to tell if the reference is a direct reference. 0.2.7 Allow Reference objects to be functions (callable) 0.2.6 Let Symbolic.__getitem__ return DirectRefItem instead of ReferenceItem 0.2.5 Allow custom evaluation for objects in verb arguments. 0.2.4 Allow extra attributes to be registered together with funcs/verbs 0.1.6 Allow to register different context for different types Allow verb to be used as argument of a verb","title":"Change log"},{"location":"changelog/#045","text":"Add CallingEnvs.REGULAR","title":"0.4.5"},{"location":"changelog/#044","text":"Add options and options_context . Move warn_astnode_failure to options Add assume_all_piping mode","title":"0.4.4"},{"location":"changelog/#043","text":"Avoid raising exception for varname() to get the name of Symbolic object.","title":"0.4.3"},{"location":"changelog/#042","text":"Make Function property private thus accessiable to getattr() (otherwise returns an Expression object) Give better repr for Function when func is an Expression object.","title":"0.4.2"},{"location":"changelog/#041","text":"Fix getattr() failure for operator-connected expressions (pwwang/datar#38)","title":"0.4.1"},{"location":"changelog/#040","text":"Improve calling rules for verbs, data functions and non-data functions Remove evaluate_args() and evaluate_kwargs() , use evaluate_expr() instead","title":"0.4.0"},{"location":"changelog/#030","text":"Added: - Add a better regular calling strategy and warn for ambiguity - Support #11 Breaking changes: - Rename register_piping_sign to register_piping","title":"0.3.0"},{"location":"changelog/#029","text":"Avoid func of Function object to be re-evaluated (fixing datar#14)","title":"0.2.9"},{"location":"changelog/#028","text":"Add is_direct argument to context getitem/getattr to tell if the reference is a direct reference.","title":"0.2.8"},{"location":"changelog/#027","text":"Allow Reference objects to be functions (callable)","title":"0.2.7"},{"location":"changelog/#026","text":"Let Symbolic.__getitem__ return DirectRefItem instead of ReferenceItem","title":"0.2.6"},{"location":"changelog/#025","text":"Allow custom evaluation for objects in verb arguments.","title":"0.2.5"},{"location":"changelog/#024","text":"Allow extra attributes to be registered together with funcs/verbs","title":"0.2.4"},{"location":"changelog/#016","text":"Allow to register different context for different types Allow verb to be used as argument of a verb","title":"0.1.6"},{"location":"api/pipda.context/","text":"module pipda . context </> Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when context is mixed, meaning args is evaluated with select and *kwargs is evaluated with evaluation. 4. when it is unset, you will need to evaluate args and kwargs yourself. Classes ContextError \u2014 Any errors related to contexts </> ContextBase ( ) \u2014 The context abstract class, defining howthe Reference objects are evaluated </> ContextSelect \u2014 Context used in a select context </> ContextEval \u2014 Context used in a data-evaluation context </> ContextPending \u2014 Pending context </> ContextMixed \u2014 A mixed context, where the *args are evaluated with ContextSelect and **args are evaluated with ContextEval . </> Context \u2014 Context to solve f.A and f['A'] </> class pipda.context . ContextError ( ) </> Bases Exception BaseException Any errors related to contexts abstract class pipda.context . ContextBase ( ) </> The context abstract class, defining howthe Reference objects are evaluated getattr defines how f.A is evaluated. Note that f.A.B will always be evaluated as getattr(f.A, 'B') getitem defines how f[item] is evaluated. Note that the item here is an evaluated value defined by getref . ref here defines how the reference/item in f.item is evaluated. Since we could do f[f.A] . Attributes args ( ContextBase ) \u2014 The context to evaluate *args passed to a function </> kwargs ( ContextBase ) \u2014 The context to evaluate **kwargs passed to a function </> name (str) \u2014 The name of the context </> ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) (any) \u2014 Defines how f.A is evaluated </> getitem ( parent , ref , is_direct ) (any) \u2014 Defines how f[item] is evaluated </> abstract method getattr ( parent , ref , is_direct=False ) \u2192 any </> Defines how f.A is evaluated abstract method getitem ( parent , ref , is_direct=False ) \u2192 any </> Defines how f[item] is evaluated class pipda.context . ContextSelect ( ) </> Bases pipda.context.ContextBase Context used in a select context In this kind of context, - f.A works as a shortcut of 'A' ; - f[ref] works as a shortcut of ref . However, ref is needed to be evaluated by a context returned by getref Attributes args ( ContextBase ) \u2014 The context to evaluate *args passed to a function </> kwargs ( ContextBase ) \u2014 The context to evaluate **kwargs passed to a function </> ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) (str) \u2014 Get the ref directly, regardless of data </> getitem ( parent , ref , is_direct ) (any) \u2014 Get the ref directly, which is already evaluated by f[ref] </> method getattr ( parent , ref , is_direct=False ) \u2192 str </> Get the ref directly, regardless of data method getitem ( parent , ref , is_direct=False ) \u2192 any </> Get the ref directly, which is already evaluated by f[ref] class pipda.context . ContextEval ( ) </> Bases pipda.context.ContextBase Context used in a data-evaluation context In this kind of context, the expression is evaluated as-is. That is, f.A is evaluated as f.A and f[item] is evaluated as f[item] Attributes args ( ContextBase ) \u2014 The context to evaluate *args passed to a function </> kwargs ( ContextBase ) \u2014 The context to evaluate **kwargs passed to a function </> ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) (any) \u2014 How to evaluate f.A </> getitem ( parent , ref , is_direct ) (any) \u2014 How to evaluate f[item] </> method getattr ( parent , ref , is_direct=False ) \u2192 any </> How to evaluate f.A method getitem ( parent , ref , is_direct=False ) \u2192 any </> How to evaluate f[item] class pipda.context . ContextPending ( ) </> Bases pipda.context.ContextBase Pending context Attributes args ( ContextBase ) \u2014 The context to evaluate *args passed to a function </> kwargs ( ContextBase ) \u2014 The context to evaluate **kwargs passed to a function </> ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) (str) \u2014 Get the ref directly, regardless of data </> getitem ( parent , ref , is_direct ) (any) \u2014 Get the ref directly, which is already evaluated by f[ref] </> method getattr ( parent , ref , is_direct=False ) \u2192 str </> Get the ref directly, regardless of data method getitem ( parent , ref , is_direct=False ) \u2192 any </> Get the ref directly, which is already evaluated by f[ref] class pipda.context . ContextMixed ( ) </> Bases pipda.context.ContextBase A mixed context, where the *args are evaluated with ContextSelect and **args are evaluated with ContextEval . Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) \u2014 Defines how f.A is evaluated </> getitem ( parent , ref , is_direct ) \u2014 Defines how f[item] is evaluated </> method getattr ( parent , ref , is_direct=False ) </> Defines how f.A is evaluated method getitem ( parent , ref , is_direct=False ) </> Defines how f[item] is evaluated class pipda.context . Context ( value , names=None , module=None , qualname=None , type=None , start=1 ) </> Bases enum.Enum Context to solve f.A and f['A'] UNSET: The function's evaluation is dependent on it's parents PENDING: Context to leave the arguments to be evaluated inside the function SELECT: It select-based context EVAL: It evaluation-based context MIXED: Mixed context. For args, used select-based; for *kwargs, use evaluation-based. Classes EnumMeta \u2014 Metaclass for Enum </> class enum. EnumMeta ( cls , bases , classdict ) </> Metaclass for Enum Attributes __members__ \u2014 Returns a mapping of member name->value. This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. </> Methods __bool__ ( ) \u2014 classes/types should always be True. </> __call__ ( cls , value , names , module , qualname , type , start ) \u2014 Either returns an existing member, or creates a new enum class. </> __dir__ ( ) \u2014 Specialized dir implementation for types. </> __getattr__ ( cls , name ) \u2014 Return the enum member matching name </> __iter__ ( cls ) \u2014 Returns members in definition order. </> __reversed__ ( cls ) \u2014 Returns members in reverse definition order. </> __setattr__ ( cls , name , value ) \u2014 Block attempts to reassign Enum members. </> method __bool__ ( ) </> classes/types should always be True. staticmethod __call__ ( cls , value , names=None , module=None , qualname=None , type=None , start=1 ) </> Either returns an existing member, or creates a new enum class. This method is used both when an enum class is given a value to match to an enumeration member (i.e. Color(3)) and for the functional API (i.e. Color = Enum('Color', names='RED GREEN BLUE')). When used for the functional API: value will be the name of the new class. names should be either a string of white-space/comma delimited names (values will start at start ), or an iterator/mapping of name, value pairs. module should be set to the module this class is being created in; if it is not set, an attempt to find that module will be made, but if it fails the class will not be picklable. qualname should be set to the actual location this class can be found at in its module; by default it is set to the global scope. If this is not correct, unpickling will fail in some circumstances. type , if set, will be mixed in as the first base class. method __dir__ ( ) </> Specialized dir implementation for types. staticmethod __getattr__ ( cls , name ) </> Return the enum member matching name We use getattr instead of descriptors or inserting into the enum class' dict in order to support name and value being both properties for enum members (which live in the class' dict ) and enum members themselves. staticmethod __iter__ ( cls ) </> Returns members in definition order. staticmethod __reversed__ ( cls ) </> Returns members in reverse definition order. staticmethod __setattr__ ( cls , name , value ) </> Block attempts to reassign Enum members. A simple assignment to the class namespace only changes one of the several possible ways to get an Enum member from the Enum class, resulting in an inconsistent Enumeration.","title":"pipda.context"},{"location":"api/pipda.context/#pipdacontext","text":"</> Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when context is mixed, meaning args is evaluated with select and *kwargs is evaluated with evaluation. 4. when it is unset, you will need to evaluate args and kwargs yourself. Classes ContextError \u2014 Any errors related to contexts </> ContextBase ( ) \u2014 The context abstract class, defining howthe Reference objects are evaluated </> ContextSelect \u2014 Context used in a select context </> ContextEval \u2014 Context used in a data-evaluation context </> ContextPending \u2014 Pending context </> ContextMixed \u2014 A mixed context, where the *args are evaluated with ContextSelect and **args are evaluated with ContextEval . </> Context \u2014 Context to solve f.A and f['A'] </> class","title":"pipda.context"},{"location":"api/pipda.context/#pipdacontextcontexterror","text":"</> Bases Exception BaseException Any errors related to contexts abstract class","title":"pipda.context.ContextError"},{"location":"api/pipda.context/#pipdacontextcontextbase","text":"</> The context abstract class, defining howthe Reference objects are evaluated getattr defines how f.A is evaluated. Note that f.A.B will always be evaluated as getattr(f.A, 'B') getitem defines how f[item] is evaluated. Note that the item here is an evaluated value defined by getref . ref here defines how the reference/item in f.item is evaluated. Since we could do f[f.A] . Attributes args ( ContextBase ) \u2014 The context to evaluate *args passed to a function </> kwargs ( ContextBase ) \u2014 The context to evaluate **kwargs passed to a function </> name (str) \u2014 The name of the context </> ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) (any) \u2014 Defines how f.A is evaluated </> getitem ( parent , ref , is_direct ) (any) \u2014 Defines how f[item] is evaluated </> abstract method","title":"pipda.context.ContextBase"},{"location":"api/pipda.context/#pipdacontextcontextbasegetattr","text":"</> Defines how f.A is evaluated abstract method","title":"pipda.context.ContextBase.getattr"},{"location":"api/pipda.context/#pipdacontextcontextbasegetitem","text":"</> Defines how f[item] is evaluated class","title":"pipda.context.ContextBase.getitem"},{"location":"api/pipda.context/#pipdacontextcontextselect","text":"</> Bases pipda.context.ContextBase Context used in a select context In this kind of context, - f.A works as a shortcut of 'A' ; - f[ref] works as a shortcut of ref . However, ref is needed to be evaluated by a context returned by getref Attributes args ( ContextBase ) \u2014 The context to evaluate *args passed to a function </> kwargs ( ContextBase ) \u2014 The context to evaluate **kwargs passed to a function </> ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) (str) \u2014 Get the ref directly, regardless of data </> getitem ( parent , ref , is_direct ) (any) \u2014 Get the ref directly, which is already evaluated by f[ref] </> method","title":"pipda.context.ContextSelect"},{"location":"api/pipda.context/#pipdacontextcontextselectgetattr","text":"</> Get the ref directly, regardless of data method","title":"pipda.context.ContextSelect.getattr"},{"location":"api/pipda.context/#pipdacontextcontextselectgetitem","text":"</> Get the ref directly, which is already evaluated by f[ref] class","title":"pipda.context.ContextSelect.getitem"},{"location":"api/pipda.context/#pipdacontextcontexteval","text":"</> Bases pipda.context.ContextBase Context used in a data-evaluation context In this kind of context, the expression is evaluated as-is. That is, f.A is evaluated as f.A and f[item] is evaluated as f[item] Attributes args ( ContextBase ) \u2014 The context to evaluate *args passed to a function </> kwargs ( ContextBase ) \u2014 The context to evaluate **kwargs passed to a function </> ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) (any) \u2014 How to evaluate f.A </> getitem ( parent , ref , is_direct ) (any) \u2014 How to evaluate f[item] </> method","title":"pipda.context.ContextEval"},{"location":"api/pipda.context/#pipdacontextcontextevalgetattr","text":"</> How to evaluate f.A method","title":"pipda.context.ContextEval.getattr"},{"location":"api/pipda.context/#pipdacontextcontextevalgetitem","text":"</> How to evaluate f[item] class","title":"pipda.context.ContextEval.getitem"},{"location":"api/pipda.context/#pipdacontextcontextpending","text":"</> Bases pipda.context.ContextBase Pending context Attributes args ( ContextBase ) \u2014 The context to evaluate *args passed to a function </> kwargs ( ContextBase ) \u2014 The context to evaluate **kwargs passed to a function </> ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) (str) \u2014 Get the ref directly, regardless of data </> getitem ( parent , ref , is_direct ) (any) \u2014 Get the ref directly, which is already evaluated by f[ref] </> method","title":"pipda.context.ContextPending"},{"location":"api/pipda.context/#pipdacontextcontextpendinggetattr","text":"</> Get the ref directly, regardless of data method","title":"pipda.context.ContextPending.getattr"},{"location":"api/pipda.context/#pipdacontextcontextpendinggetitem","text":"</> Get the ref directly, which is already evaluated by f[ref] class","title":"pipda.context.ContextPending.getitem"},{"location":"api/pipda.context/#pipdacontextcontextmixed","text":"</> Bases pipda.context.ContextBase A mixed context, where the *args are evaluated with ContextSelect and **args are evaluated with ContextEval . Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , is_direct ) \u2014 Defines how f.A is evaluated </> getitem ( parent , ref , is_direct ) \u2014 Defines how f[item] is evaluated </> method","title":"pipda.context.ContextMixed"},{"location":"api/pipda.context/#pipdacontextcontextmixedgetattr","text":"</> Defines how f.A is evaluated method","title":"pipda.context.ContextMixed.getattr"},{"location":"api/pipda.context/#pipdacontextcontextmixedgetitem","text":"</> Defines how f[item] is evaluated class","title":"pipda.context.ContextMixed.getitem"},{"location":"api/pipda.context/#pipdacontextcontext","text":"</> Bases enum.Enum Context to solve f.A and f['A'] UNSET: The function's evaluation is dependent on it's parents PENDING: Context to leave the arguments to be evaluated inside the function SELECT: It select-based context EVAL: It evaluation-based context MIXED: Mixed context. For args, used select-based; for *kwargs, use evaluation-based. Classes EnumMeta \u2014 Metaclass for Enum </> class","title":"pipda.context.Context"},{"location":"api/pipda.context/#enumenummeta","text":"</> Metaclass for Enum Attributes __members__ \u2014 Returns a mapping of member name->value. This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. </> Methods __bool__ ( ) \u2014 classes/types should always be True. </> __call__ ( cls , value , names , module , qualname , type , start ) \u2014 Either returns an existing member, or creates a new enum class. </> __dir__ ( ) \u2014 Specialized dir implementation for types. </> __getattr__ ( cls , name ) \u2014 Return the enum member matching name </> __iter__ ( cls ) \u2014 Returns members in definition order. </> __reversed__ ( cls ) \u2014 Returns members in reverse definition order. </> __setattr__ ( cls , name , value ) \u2014 Block attempts to reassign Enum members. </> method __bool__ ( ) </> classes/types should always be True. staticmethod __call__ ( cls , value , names=None , module=None , qualname=None , type=None , start=1 ) </> Either returns an existing member, or creates a new enum class. This method is used both when an enum class is given a value to match to an enumeration member (i.e. Color(3)) and for the functional API (i.e. Color = Enum('Color', names='RED GREEN BLUE')). When used for the functional API: value will be the name of the new class. names should be either a string of white-space/comma delimited names (values will start at start ), or an iterator/mapping of name, value pairs. module should be set to the module this class is being created in; if it is not set, an attempt to find that module will be made, but if it fails the class will not be picklable. qualname should be set to the actual location this class can be found at in its module; by default it is set to the global scope. If this is not correct, unpickling will fail in some circumstances. type , if set, will be mixed in as the first base class. method __dir__ ( ) </> Specialized dir implementation for types. staticmethod __getattr__ ( cls , name ) </> Return the enum member matching name We use getattr instead of descriptors or inserting into the enum class' dict in order to support name and value being both properties for enum members (which live in the class' dict ) and enum members themselves. staticmethod __iter__ ( cls ) </> Returns members in definition order. staticmethod __reversed__ ( cls ) </> Returns members in reverse definition order. staticmethod __setattr__ ( cls , name , value ) </> Block attempts to reassign Enum members. A simple assignment to the class namespace only changes one of the several possible ways to get an Enum member from the Enum class, resulting in an inconsistent Enumeration.","title":"enum.EnumMeta"},{"location":"api/pipda.expression/","text":"module pipda . expression </> Provides the abstract class Expression Classes Expression ( ) \u2014 The abstract Expression class </> abstract class pipda.expression . Expression ( ) </> The abstract Expression class Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs","title":"pipda.expression"},{"location":"api/pipda.expression/#pipdaexpression","text":"</> Provides the abstract class Expression Classes Expression ( ) \u2014 The abstract Expression class </> abstract class","title":"pipda.expression"},{"location":"api/pipda.expression/#pipdaexpressionexpression","text":"</> The abstract Expression class Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.expression.Expression"},{"location":"api/pipda.expression/#pipdaexpressionexpressionhash","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.expression/#pipdaexpressionexpressiongetattr","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.expression/#pipdaexpressionexpressiongetitem","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.expression/#pipdaexpressionexpressionindex","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.expression/#pipdaexpressionexpressioniter","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.function/","text":"module pipda . function </> Provides register_func to register functions Classes Function \u2014 The Function class, defining how the function should be executedwhen needed </> FastEvalFunction \u2014 Fast evaluation function </> class pipda.function . Function ( func , args , kwargs , dataarg=True ) </> Bases pipda.expression.Expression The Function class, defining how the function should be executedwhen needed Parameters func (callable or Expression ) \u2014 The function to execute Attributes args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs class pipda.function . FastEvalFunction ( func , args , kwargs , dataarg=True ) </> Bases pipda.function.Function pipda.expression.Expression Fast evaluation function Parameters func (callable or Expression ) \u2014 The function to execute Attributes args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs","title":"pipda.function"},{"location":"api/pipda.function/#pipdafunction","text":"</> Provides register_func to register functions Classes Function \u2014 The Function class, defining how the function should be executedwhen needed </> FastEvalFunction \u2014 Fast evaluation function </> class","title":"pipda.function"},{"location":"api/pipda.function/#pipdafunctionfunction","text":"</> Bases pipda.expression.Expression The Function class, defining how the function should be executedwhen needed Parameters func (callable or Expression ) \u2014 The function to execute Attributes args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.function.Function"},{"location":"api/pipda.function/#pipdaexpressionexpressionhash","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.function/#pipdaexpressionexpressiongetattr","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.function/#pipdaexpressionexpressiongetitem","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.function/#pipdaexpressionexpressionindex","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.function/#pipdaexpressionexpressioniter","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs class","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.function/#pipdafunctionfastevalfunction","text":"</> Bases pipda.function.Function pipda.expression.Expression Fast evaluation function Parameters func (callable or Expression ) \u2014 The function to execute Attributes args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.function.FastEvalFunction"},{"location":"api/pipda.function/#pipdaexpressionexpressionhash_1","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.function/#pipdaexpressionexpressiongetattr_1","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.function/#pipdaexpressionexpressiongetitem_1","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.function/#pipdaexpressionexpressionindex_1","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.function/#pipdaexpressionexpressioniter_1","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs","title":"pipda.expression.Expression.iter"},{"location":"api/pipda/","text":"package pipda </> A framework for data piping in python module pipda . utils </> Provide utilities Classes InaccessibleToNULLException \u2014 Raises when access to NULLClass object </> NULLClass \u2014 Sometimes, None is a valid option. In order to distinguish thissituation, NULL is used for a default. </> CallingEnvs \u2014 Types of piping/calling envs </> DataEnv \u2014 A data context that can be accessed by the function registered by pipda.register_* so that the data argument doesn't need to be passed when called </> Functions bind_arguments ( func , args , kwargs ) (BoundArguments) \u2014 Try to bind arguments, instead of run the function to see if argumentscan fit the function </> calling_env ( funtype ) (any) \u2014 Checking how the function is called: </> evaluate_expr ( expr , data , context ) (any) \u2014 Evaluate a mixed expression </> functype ( func ) (str) \u2014 Check the type of the function </> get_env_data ( frame ) (any) \u2014 Check and return if there is a data set in the context wherethe verb or function is called </> has_expr ( expr ) (bool) \u2014 Check if expr has any Expression object in it </> options_context ( **kwargs ) (generator(T_co, T_contra, V_co)) \u2014 A context manager to execute code with temporary options </> module pipda . function </> Provides register_func to register functions Classes Function \u2014 The Function class, defining how the function should be executedwhen needed </> FastEvalFunction \u2014 Fast evaluation function </> module pipda . operator </> Provide the Operator class Classes Operator \u2014 Operator class, defining how the operators in verb/function argumentsshould be evaluated </> module pipda . context </> Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when context is mixed, meaning args is evaluated with select and *kwargs is evaluated with evaluation. 4. when it is unset, you will need to evaluate args and kwargs yourself. Classes ContextError \u2014 Any errors related to contexts </> ContextBase ( ) \u2014 The context abstract class, defining howthe Reference objects are evaluated </> ContextSelect \u2014 Context used in a select context </> ContextEval \u2014 Context used in a data-evaluation context </> ContextPending \u2014 Pending context </> ContextMixed \u2014 A mixed context, where the *args are evaluated with ContextSelect and **args are evaluated with ContextEval . </> Context \u2014 Context to solve f.A and f['A'] </> module pipda . symbolic </> Provides Symbolic and Reference classes Classes Reference ( parent , ref ) \u2014 The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) </> ReferenceAttr \u2014 Attribute references, for example: f.A , f.A.B etc. </> ReferenceItem \u2014 Subscript references, for example: f['A'] , f.A['B'] etc </> DirectRefAttr \u2014 The direct attribute reference, such as f.A </> DirectRefItem \u2014 The direct attribute reference, such as f['A'] </> Symbolic \u2014 The symbolic class, works as a proxy to represent the data </> module pipda . verb </> Provide register_verb to register verbs Classes Verb \u2014 The verb class </> FastEvalVerb \u2014 Verbs that can use its first argument to evaluate </> module pipda . expression </> Provides the abstract class Expression Classes Expression ( ) \u2014 The abstract Expression class </> module pipda . register </> Provide register_* suite Classes Sign \u2014 Sign(method, token) </> Functions register_func ( types , context , func , verb_arg_only , extra_contexts , **attrs ) (callable) \u2014 Register a function to be used in verb </> register_operator ( op_class ) (type of Operator ) \u2014 Register an Operator class </> register_piping ( sign ) \u2014 Register a piping sign for the verbs </> register_verb ( types , context , func , extra_contexts , **attrs ) (callable) \u2014 Register a verb with specific types of data </> unregister ( func ) (callable) \u2014 Get the original function before register </>","title":"pipda"},{"location":"api/pipda/#pipda","text":"</> A framework for data piping in python module","title":"pipda"},{"location":"api/pipda/#pipdautils","text":"</> Provide utilities Classes InaccessibleToNULLException \u2014 Raises when access to NULLClass object </> NULLClass \u2014 Sometimes, None is a valid option. In order to distinguish thissituation, NULL is used for a default. </> CallingEnvs \u2014 Types of piping/calling envs </> DataEnv \u2014 A data context that can be accessed by the function registered by pipda.register_* so that the data argument doesn't need to be passed when called </> Functions bind_arguments ( func , args , kwargs ) (BoundArguments) \u2014 Try to bind arguments, instead of run the function to see if argumentscan fit the function </> calling_env ( funtype ) (any) \u2014 Checking how the function is called: </> evaluate_expr ( expr , data , context ) (any) \u2014 Evaluate a mixed expression </> functype ( func ) (str) \u2014 Check the type of the function </> get_env_data ( frame ) (any) \u2014 Check and return if there is a data set in the context wherethe verb or function is called </> has_expr ( expr ) (bool) \u2014 Check if expr has any Expression object in it </> options_context ( **kwargs ) (generator(T_co, T_contra, V_co)) \u2014 A context manager to execute code with temporary options </> module","title":"pipda.utils"},{"location":"api/pipda/#pipdafunction","text":"</> Provides register_func to register functions Classes Function \u2014 The Function class, defining how the function should be executedwhen needed </> FastEvalFunction \u2014 Fast evaluation function </> module","title":"pipda.function"},{"location":"api/pipda/#pipdaoperator","text":"</> Provide the Operator class Classes Operator \u2014 Operator class, defining how the operators in verb/function argumentsshould be evaluated </> module","title":"pipda.operator"},{"location":"api/pipda/#pipdacontext","text":"</> Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when context is mixed, meaning args is evaluated with select and *kwargs is evaluated with evaluation. 4. when it is unset, you will need to evaluate args and kwargs yourself. Classes ContextError \u2014 Any errors related to contexts </> ContextBase ( ) \u2014 The context abstract class, defining howthe Reference objects are evaluated </> ContextSelect \u2014 Context used in a select context </> ContextEval \u2014 Context used in a data-evaluation context </> ContextPending \u2014 Pending context </> ContextMixed \u2014 A mixed context, where the *args are evaluated with ContextSelect and **args are evaluated with ContextEval . </> Context \u2014 Context to solve f.A and f['A'] </> module","title":"pipda.context"},{"location":"api/pipda/#pipdasymbolic","text":"</> Provides Symbolic and Reference classes Classes Reference ( parent , ref ) \u2014 The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) </> ReferenceAttr \u2014 Attribute references, for example: f.A , f.A.B etc. </> ReferenceItem \u2014 Subscript references, for example: f['A'] , f.A['B'] etc </> DirectRefAttr \u2014 The direct attribute reference, such as f.A </> DirectRefItem \u2014 The direct attribute reference, such as f['A'] </> Symbolic \u2014 The symbolic class, works as a proxy to represent the data </> module","title":"pipda.symbolic"},{"location":"api/pipda/#pipdaverb","text":"</> Provide register_verb to register verbs Classes Verb \u2014 The verb class </> FastEvalVerb \u2014 Verbs that can use its first argument to evaluate </> module","title":"pipda.verb"},{"location":"api/pipda/#pipdaexpression","text":"</> Provides the abstract class Expression Classes Expression ( ) \u2014 The abstract Expression class </> module","title":"pipda.expression"},{"location":"api/pipda/#pipdaregister","text":"</> Provide register_* suite Classes Sign \u2014 Sign(method, token) </> Functions register_func ( types , context , func , verb_arg_only , extra_contexts , **attrs ) (callable) \u2014 Register a function to be used in verb </> register_operator ( op_class ) (type of Operator ) \u2014 Register an Operator class </> register_piping ( sign ) \u2014 Register a piping sign for the verbs </> register_verb ( types , context , func , extra_contexts , **attrs ) (callable) \u2014 Register a verb with specific types of data </> unregister ( func ) (callable) \u2014 Get the original function before register </>","title":"pipda.register"},{"location":"api/pipda.operator/","text":"module pipda . operator </> Provide the Operator class Classes Operator \u2014 Operator class, defining how the operators in verb/function argumentsshould be evaluated </> class pipda.operator . Operator ( op , args , kwargs , datarg=False ) </> Bases pipda.function.Function pipda.expression.Expression Operator class, defining how the operators in verb/function argumentsshould be evaluated Parameters args (tuple) \u2014 The arguments of the operator kwargs \u2014 The keyword arguments of the operator op (str) \u2014 The operator datarg (bool, optional) \u2014 Should be False. No data argument for the operator function. Attributes REGISTERED \u2014 The registered Operator class. It's this class by defaultUse register_operator as a decorator to register a operator class args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> set_context ( context , extra_contexts ) (callable(callable: callable)) \u2014 Set custom context for a operator method </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs staticmethod set_context ( context , extra_contexts=None ) \u2192 callable(callable: callable) </> Set custom context for a operator method","title":"pipda.operator"},{"location":"api/pipda.operator/#pipdaoperator","text":"</> Provide the Operator class Classes Operator \u2014 Operator class, defining how the operators in verb/function argumentsshould be evaluated </> class","title":"pipda.operator"},{"location":"api/pipda.operator/#pipdaoperatoroperator","text":"</> Bases pipda.function.Function pipda.expression.Expression Operator class, defining how the operators in verb/function argumentsshould be evaluated Parameters args (tuple) \u2014 The arguments of the operator kwargs \u2014 The keyword arguments of the operator op (str) \u2014 The operator datarg (bool, optional) \u2014 Should be False. No data argument for the operator function. Attributes REGISTERED \u2014 The registered Operator class. It's this class by defaultUse register_operator as a decorator to register a operator class args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> set_context ( context , extra_contexts ) (callable(callable: callable)) \u2014 Set custom context for a operator method </> method","title":"pipda.operator.Operator"},{"location":"api/pipda.operator/#pipdaexpressionexpressionhash","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.operator/#pipdaexpressionexpressiongetattr","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.operator/#pipdaexpressionexpressiongetitem","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.operator/#pipdaexpressionexpressionindex","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.operator/#pipdaexpressionexpressioniter","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs staticmethod","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.operator/#pipdaoperatoroperatorset_context","text":"</> Set custom context for a operator method","title":"pipda.operator.Operator.set_context"},{"location":"api/pipda.register/","text":"module pipda . register </> Provide register_* suite Classes Sign \u2014 Sign(method, token) </> Functions register_func ( types , context , func , verb_arg_only , extra_contexts , **attrs ) (callable) \u2014 Register a function to be used in verb </> register_operator ( op_class ) (type of Operator ) \u2014 Register an Operator class </> register_piping ( sign ) \u2014 Register a piping sign for the verbs </> register_verb ( types , context , func , extra_contexts , **attrs ) (callable) \u2014 Register a verb with specific types of data </> unregister ( func ) (callable) \u2014 Get the original function before register </> class pipda.register . Sign ( method , token ) </> Bases tuple Sign(method, token) function pipda.register . register_piping ( sign ) </> Register a piping sign for the verbs This actually attaches the _pipda_eval method to the method defined in PIPING_SIGNS . Parameters sign (str) \u2014 One of the signs in PIPING_SIGNS function pipda.register . register_verb ( types=<class 'object'> , context=None , func=None , extra_contexts=None , **attrs ) </> Register a verb with specific types of data If func is not given (works like register_verb(cls, context=...) ), it returns a function, works as a decorator. For example >>> @register_verb ( DataFrame , context = Context . EVAL ) >>> def verb ( data , ... ): >>> ... When function is passed as a non-keyword argument, other arguments are as defaults >>> @register_verb >>> def verb ( data , ... ): >>> ... In such a case, it is like a generic function to work with all types of data. Verb calling rules 1. data >> verb(...) First argument should not be passed, using the data 2. data >> other_verb(verb(...)) First argument used, and a Function object will be returned from the verb. f represents the data, instead of the first argument of the verb. 3. verb(...) Called independently. The verb will be called regularly anyway. The first argument will be used as data to evaluate the arguments if there are any Expression objects 4. verb(...) with DataEnv First argument should not be passed in, will use the DataEnv's data to evaluate the arguments Parameters types (Union(function, type, iterable of type), optional) \u2014 The types of data for the verbMultiple types are supported to be passed as a list/tuple/set. It cannot be None for verbs. context ( Context or ContextBase , optional) \u2014 The context to evaluate the Expression objects func (function, optional) \u2014 The function to be decorated if passed explicitly extra_contexts (, optional) \u2014 Extra contexts (if not the same as context )for specific arguments **attrs (any) \u2014 Other attributes to be attached to the function Returns (callable) A decorator function if func is not given or a wrapper functionlike a singledispatch generic function that can register other types, show all registry and dispatch for a specific type function pipda.register . register_func ( types=<class 'object'> , context=None , func=None , verb_arg_only=False , extra_contexts=None , **attrs ) </> Register a function to be used in verb If func is not given (works like register_verb(cls, context=...) ), it returns a function, works as a decorator. For example >>> @register_func ( numpy . ndarray , context = Context . EVAL ) >>> def func ( data , ... ): >>> ... When function is passed as a non-keyword argument, other arguments are as defaults >>> @register_func >>> def func ( data , ... ): >>> ... In such a case, it is like a generic function to work with all types of data. data is not a required argument. If not required, cls should be specified as None . Data function calling rules 1. data >> verb(func(...)) First argument is not used. Will use data 2. func(...) Called independently. The function will be called regularly anyway. Similar as Verb calling rule, but first argument will not be used for evaluation 3. func(...) with DataEnv First argument not used, passed implicitly with DataEnv. Non-data function calling rules: 1. data >> verb(func(...)) Return a Function object waiting for evaluation 2. func(...) Called regularly anyway 3. func(...) with DataEnv Evaluate with DataEnv. For example: mean(f.x) Parameters types (Union(function, type, iterable of type), optional) \u2014 The classes of data for the verbMultiple classes are supported to be passed as a list/tuple/set. None means no data argument for the function context ( Context , ContextBase , or NoneType, optional) \u2014 The context to evaluate the Expression objects func (function, optional) \u2014 The function to be decorated if passed explicitly verb_arg_only (bool, optional) \u2014 Whether the function should be only used as an argumentof a verb. This means it only works in the format of data >> verb(..., func(...), ...) Note that even this won't work verb(data, ..., func(...), ...) extra_contexts (, optional) \u2014 Extra contexts (if not the same as context )for specific arguments **attrs (any) \u2014 Other attributes to be attached to the function Returns (callable) A decorator function if func is not given or a wrapper functionlike a singledispatch generic function that can register other types, show all registry and dispatch for a specific type function pipda.register . register_operator ( op_class ) </> Register an Operator class Working as a decorator for a class subclassed from Operator. Parameters op_class (type of Operator ) \u2014 The operator class Returns (type of Operator ) The decorated operator class function pipda.register . unregister ( func ) </> Get the original function before register Parameters func (callable) \u2014 The function that is either registered by register_verb or register_func Returns (callable) The original function that before register","title":"pipda.register"},{"location":"api/pipda.register/#pipdaregister","text":"</> Provide register_* suite Classes Sign \u2014 Sign(method, token) </> Functions register_func ( types , context , func , verb_arg_only , extra_contexts , **attrs ) (callable) \u2014 Register a function to be used in verb </> register_operator ( op_class ) (type of Operator ) \u2014 Register an Operator class </> register_piping ( sign ) \u2014 Register a piping sign for the verbs </> register_verb ( types , context , func , extra_contexts , **attrs ) (callable) \u2014 Register a verb with specific types of data </> unregister ( func ) (callable) \u2014 Get the original function before register </> class","title":"pipda.register"},{"location":"api/pipda.register/#pipdaregistersign","text":"</> Bases tuple Sign(method, token) function","title":"pipda.register.Sign"},{"location":"api/pipda.register/#pipdaregisterregister_piping","text":"</> Register a piping sign for the verbs This actually attaches the _pipda_eval method to the method defined in PIPING_SIGNS . Parameters sign (str) \u2014 One of the signs in PIPING_SIGNS function","title":"pipda.register.register_piping"},{"location":"api/pipda.register/#pipdaregisterregister_verb","text":"</> Register a verb with specific types of data If func is not given (works like register_verb(cls, context=...) ), it returns a function, works as a decorator. For example >>> @register_verb ( DataFrame , context = Context . EVAL ) >>> def verb ( data , ... ): >>> ... When function is passed as a non-keyword argument, other arguments are as defaults >>> @register_verb >>> def verb ( data , ... ): >>> ... In such a case, it is like a generic function to work with all types of data. Verb calling rules 1. data >> verb(...) First argument should not be passed, using the data 2. data >> other_verb(verb(...)) First argument used, and a Function object will be returned from the verb. f represents the data, instead of the first argument of the verb. 3. verb(...) Called independently. The verb will be called regularly anyway. The first argument will be used as data to evaluate the arguments if there are any Expression objects 4. verb(...) with DataEnv First argument should not be passed in, will use the DataEnv's data to evaluate the arguments Parameters types (Union(function, type, iterable of type), optional) \u2014 The types of data for the verbMultiple types are supported to be passed as a list/tuple/set. It cannot be None for verbs. context ( Context or ContextBase , optional) \u2014 The context to evaluate the Expression objects func (function, optional) \u2014 The function to be decorated if passed explicitly extra_contexts (, optional) \u2014 Extra contexts (if not the same as context )for specific arguments **attrs (any) \u2014 Other attributes to be attached to the function Returns (callable) A decorator function if func is not given or a wrapper functionlike a singledispatch generic function that can register other types, show all registry and dispatch for a specific type function","title":"pipda.register.register_verb"},{"location":"api/pipda.register/#pipdaregisterregister_func","text":"</> Register a function to be used in verb If func is not given (works like register_verb(cls, context=...) ), it returns a function, works as a decorator. For example >>> @register_func ( numpy . ndarray , context = Context . EVAL ) >>> def func ( data , ... ): >>> ... When function is passed as a non-keyword argument, other arguments are as defaults >>> @register_func >>> def func ( data , ... ): >>> ... In such a case, it is like a generic function to work with all types of data. data is not a required argument. If not required, cls should be specified as None . Data function calling rules 1. data >> verb(func(...)) First argument is not used. Will use data 2. func(...) Called independently. The function will be called regularly anyway. Similar as Verb calling rule, but first argument will not be used for evaluation 3. func(...) with DataEnv First argument not used, passed implicitly with DataEnv. Non-data function calling rules: 1. data >> verb(func(...)) Return a Function object waiting for evaluation 2. func(...) Called regularly anyway 3. func(...) with DataEnv Evaluate with DataEnv. For example: mean(f.x) Parameters types (Union(function, type, iterable of type), optional) \u2014 The classes of data for the verbMultiple classes are supported to be passed as a list/tuple/set. None means no data argument for the function context ( Context , ContextBase , or NoneType, optional) \u2014 The context to evaluate the Expression objects func (function, optional) \u2014 The function to be decorated if passed explicitly verb_arg_only (bool, optional) \u2014 Whether the function should be only used as an argumentof a verb. This means it only works in the format of data >> verb(..., func(...), ...) Note that even this won't work verb(data, ..., func(...), ...) extra_contexts (, optional) \u2014 Extra contexts (if not the same as context )for specific arguments **attrs (any) \u2014 Other attributes to be attached to the function Returns (callable) A decorator function if func is not given or a wrapper functionlike a singledispatch generic function that can register other types, show all registry and dispatch for a specific type function","title":"pipda.register.register_func"},{"location":"api/pipda.register/#pipdaregisterregister_operator","text":"</> Register an Operator class Working as a decorator for a class subclassed from Operator. Parameters op_class (type of Operator ) \u2014 The operator class Returns (type of Operator ) The decorated operator class function","title":"pipda.register.register_operator"},{"location":"api/pipda.register/#pipdaregisterunregister","text":"</> Get the original function before register Parameters func (callable) \u2014 The function that is either registered by register_verb or register_func Returns (callable) The original function that before register","title":"pipda.register.unregister"},{"location":"api/pipda.symbolic/","text":"module pipda . symbolic </> Provides Symbolic and Reference classes Classes Reference ( parent , ref ) \u2014 The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) </> ReferenceAttr \u2014 Attribute references, for example: f.A , f.A.B etc. </> ReferenceItem \u2014 Subscript references, for example: f['A'] , f.A['B'] etc </> DirectRefAttr \u2014 The direct attribute reference, such as f.A </> DirectRefItem \u2014 The direct attribute reference, such as f['A'] </> Symbolic \u2014 The symbolic class, works as a proxy to represent the data </> abstract class pipda.symbolic . Reference ( parent , ref ) </> Bases pipda.expression.Expression The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B context \u2014 Defaults to None , which should not be specified whileinstansiation. Because these types of expressions are independent. A context should be passed to evaluate to evaluate the expression. Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method __call__ ( *args , **kwargs ) </> Allow f.a.b to be a function, so that one can do f.a.b(1) class pipda.symbolic . ReferenceAttr ( parent , ref ) </> Bases pipda.symbolic.Reference pipda.expression.Expression Attribute references, for example: f.A , f.A.B etc. Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method __call__ ( *args , **kwargs ) </> Allow f.a.b to be a function, so that one can do f.a.b(1) class pipda.symbolic . ReferenceItem ( parent , ref ) </> Bases pipda.symbolic.Reference pipda.expression.Expression Subscript references, for example: f['A'] , f.A['B'] etc Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method __call__ ( *args , **kwargs ) </> Allow f.a.b to be a function, so that one can do f.a.b(1) class pipda.symbolic . DirectRefAttr ( parent , ref ) </> Bases pipda.symbolic.ReferenceAttr pipda.symbolic.Reference pipda.expression.Expression The direct attribute reference, such as f.A Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method __call__ ( *args , **kwargs ) </> Allow f.a.b to be a function, so that one can do f.a.b(1) class pipda.symbolic . DirectRefItem ( parent , ref ) </> Bases pipda.symbolic.ReferenceItem pipda.symbolic.Reference pipda.expression.Expression The direct attribute reference, such as f['A'] Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method __call__ ( *args , **kwargs ) </> Allow f.a.b to be a function, so that one can do f.a.b(1) class pipda.symbolic . Symbolic ( name=None ) </> Bases pipda.expression.Expression The symbolic class, works as a proxy to represent the data In most cases it is used to construct the Reference objects. Methods __getattr__ ( name ) (any) \u2014 Create a DirectRefAttr object </> __getitem__ ( item ) (any) \u2014 Create a DirectRefItem object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method __getattr__ ( name ) \u2192 any </> Create a DirectRefAttr object method __getitem__ ( item ) \u2192 any </> Create a DirectRefItem object","title":"pipda.symbolic"},{"location":"api/pipda.symbolic/#pipdasymbolic","text":"</> Provides Symbolic and Reference classes Classes Reference ( parent , ref ) \u2014 The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) </> ReferenceAttr \u2014 Attribute references, for example: f.A , f.A.B etc. </> ReferenceItem \u2014 Subscript references, for example: f['A'] , f.A['B'] etc </> DirectRefAttr \u2014 The direct attribute reference, such as f.A </> DirectRefItem \u2014 The direct attribute reference, such as f['A'] </> Symbolic \u2014 The symbolic class, works as a proxy to represent the data </> abstract class","title":"pipda.symbolic"},{"location":"api/pipda.symbolic/#pipdasymbolicreference","text":"</> Bases pipda.expression.Expression The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B context \u2014 Defaults to None , which should not be specified whileinstansiation. Because these types of expressions are independent. A context should be passed to evaluate to evaluate the expression. Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.symbolic.Reference"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionhash","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetattr","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetitem","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionindex","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressioniter","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.symbolic/#pipdasymbolicreferencecall","text":"</> Allow f.a.b to be a function, so that one can do f.a.b(1) class","title":"pipda.symbolic.Reference.call"},{"location":"api/pipda.symbolic/#pipdasymbolicreferenceattr","text":"</> Bases pipda.symbolic.Reference pipda.expression.Expression Attribute references, for example: f.A , f.A.B etc. Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.symbolic.ReferenceAttr"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionhash_1","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetattr_1","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetitem_1","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionindex_1","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressioniter_1","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.symbolic/#pipdasymbolicreferencecall_1","text":"</> Allow f.a.b to be a function, so that one can do f.a.b(1) class","title":"pipda.symbolic.Reference.call"},{"location":"api/pipda.symbolic/#pipdasymbolicreferenceitem","text":"</> Bases pipda.symbolic.Reference pipda.expression.Expression Subscript references, for example: f['A'] , f.A['B'] etc Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.symbolic.ReferenceItem"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionhash_2","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetattr_2","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetitem_2","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionindex_2","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressioniter_2","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.symbolic/#pipdasymbolicreferencecall_2","text":"</> Allow f.a.b to be a function, so that one can do f.a.b(1) class","title":"pipda.symbolic.Reference.call"},{"location":"api/pipda.symbolic/#pipdasymbolicdirectrefattr","text":"</> Bases pipda.symbolic.ReferenceAttr pipda.symbolic.Reference pipda.expression.Expression The direct attribute reference, such as f.A Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.symbolic.DirectRefAttr"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionhash_3","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetattr_3","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetitem_3","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionindex_3","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressioniter_3","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.symbolic/#pipdasymbolicreferencecall_3","text":"</> Allow f.a.b to be a function, so that one can do f.a.b(1) class","title":"pipda.symbolic.Reference.call"},{"location":"api/pipda.symbolic/#pipdasymbolicdirectrefitem","text":"</> Bases pipda.symbolic.ReferenceItem pipda.symbolic.Reference pipda.expression.Expression The direct attribute reference, such as f['A'] Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __call__ ( *args , **kwargs ) \u2014 Allow f.a.b to be a function, so that one can do f.a.b(1) </> __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.symbolic.DirectRefItem"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionhash_4","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetattr_4","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressiongetitem_4","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionindex_4","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressioniter_4","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.symbolic/#pipdasymbolicreferencecall_4","text":"</> Allow f.a.b to be a function, so that one can do f.a.b(1) class","title":"pipda.symbolic.Reference.call"},{"location":"api/pipda.symbolic/#pipdasymbolicsymbolic","text":"</> Bases pipda.expression.Expression The symbolic class, works as a proxy to represent the data In most cases it is used to construct the Reference objects. Methods __getattr__ ( name ) (any) \u2014 Create a DirectRefAttr object </> __getitem__ ( item ) (any) \u2014 Create a DirectRefItem object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.symbolic.Symbolic"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionhash_5","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressionindex_5","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.symbolic/#pipdaexpressionexpressioniter_5","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.symbolic/#pipdasymbolicsymbolicgetattr","text":"</> Create a DirectRefAttr object method","title":"pipda.symbolic.Symbolic.getattr"},{"location":"api/pipda.symbolic/#pipdasymbolicsymbolicgetitem","text":"</> Create a DirectRefItem object","title":"pipda.symbolic.Symbolic.getitem"},{"location":"api/pipda.utils/","text":"module pipda . utils </> Provide utilities Classes InaccessibleToNULLException \u2014 Raises when access to NULLClass object </> NULLClass \u2014 Sometimes, None is a valid option. In order to distinguish thissituation, NULL is used for a default. </> CallingEnvs \u2014 Types of piping/calling envs </> DataEnv \u2014 A data context that can be accessed by the function registered by pipda.register_* so that the data argument doesn't need to be passed when called </> Functions bind_arguments ( func , args , kwargs ) (BoundArguments) \u2014 Try to bind arguments, instead of run the function to see if argumentscan fit the function </> calling_env ( funtype ) (any) \u2014 Checking how the function is called: </> evaluate_expr ( expr , data , context ) (any) \u2014 Evaluate a mixed expression </> functype ( func ) (str) \u2014 Check the type of the function </> get_env_data ( frame ) (any) \u2014 Check and return if there is a data set in the context wherethe verb or function is called </> has_expr ( expr ) (bool) \u2014 Check if expr has any Expression object in it </> options_context ( **kwargs ) (generator(T_co, T_contra, V_co)) \u2014 A context manager to execute code with temporary options </> generator pipda.utils . options_context ( **kwargs ) \u2192 generator(T_co, T_contra, V_co) </> A context manager to execute code with temporary options class pipda.utils . InaccessibleToNULLException ( ) </> Bases Exception BaseException Raises when access to NULLClass object class pipda.utils . NULLClass ( ) </> Sometimes, None is a valid option. In order to distinguish thissituation, NULL is used for a default. It is also used as data to fast evaluate FastEvalFunction and FastEvalVerb objects. If failed, InaccessibleToNULLException will be raised. Methods __repr__ ( ) (str) \u2014 String representation </> method __repr__ ( ) \u2192 str </> String representation class pipda.utils . CallingEnvs ( value , names=None , module=None , qualname=None , type=None , start=1 ) </> Bases enum.Enum Types of piping/calling envs Classes EnumMeta \u2014 Metaclass for Enum </> class enum. EnumMeta ( cls , bases , classdict ) </> Metaclass for Enum Attributes __members__ \u2014 Returns a mapping of member name->value. This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. </> Methods __bool__ ( ) \u2014 classes/types should always be True. </> __call__ ( cls , value , names , module , qualname , type , start ) \u2014 Either returns an existing member, or creates a new enum class. </> __dir__ ( ) \u2014 Specialized dir implementation for types. </> __getattr__ ( cls , name ) \u2014 Return the enum member matching name </> __iter__ ( cls ) \u2014 Returns members in definition order. </> __reversed__ ( cls ) \u2014 Returns members in reverse definition order. </> __setattr__ ( cls , name , value ) \u2014 Block attempts to reassign Enum members. </> method __bool__ ( ) </> classes/types should always be True. staticmethod __call__ ( cls , value , names=None , module=None , qualname=None , type=None , start=1 ) </> Either returns an existing member, or creates a new enum class. This method is used both when an enum class is given a value to match to an enumeration member (i.e. Color(3)) and for the functional API (i.e. Color = Enum('Color', names='RED GREEN BLUE')). When used for the functional API: value will be the name of the new class. names should be either a string of white-space/comma delimited names (values will start at start ), or an iterator/mapping of name, value pairs. module should be set to the module this class is being created in; if it is not set, an attempt to find that module will be made, but if it fails the class will not be picklable. qualname should be set to the actual location this class can be found at in its module; by default it is set to the global scope. If this is not correct, unpickling will fail in some circumstances. type , if set, will be mixed in as the first base class. method __dir__ ( ) </> Specialized dir implementation for types. staticmethod __getattr__ ( cls , name ) </> Return the enum member matching name We use getattr instead of descriptors or inserting into the enum class' dict in order to support name and value being both properties for enum members (which live in the class' dict ) and enum members themselves. staticmethod __iter__ ( cls ) </> Returns members in definition order. staticmethod __reversed__ ( cls ) </> Returns members in reverse definition order. staticmethod __setattr__ ( cls , name , value ) </> Block attempts to reassign Enum members. A simple assignment to the class namespace only changes one of the several possible ways to get an Enum member from the Enum class, resulting in an inconsistent Enumeration. class pipda.utils . DataEnv ( data , name='__pipda_context_data__' ) </> A data context that can be accessed by the function registered by pipda.register_* so that the data argument doesn't need to be passed when called Parameters data (any) \u2014 The data to be attached to the context Methods delete ( ) \u2014 Delete the attached data </> get ( ) (any) \u2014 Get the data </> set ( data ) \u2014 Update the data </> method get ( ) \u2192 any </> Get the data method set ( data ) </> Update the data method delete ( ) </> Delete the attached data function pipda.utils . get_env_data ( frame ) \u2192 any </> Check and return if there is a data set in the context wherethe verb or function is called The data has to be named as _ function pipda.utils . calling_env ( funtype ) \u2192 any </> Checking how the function is called: PIPING_VERB: It is a verb that is piped directed. ie. data >> verb(...) PIPING: It is a function called as (part of) the argument of a piping verb. ie.: >>> data >> verb ( func ( ... )) Note that `func` here could also be a verb. When a function is called inside a lambda body, it should not be counted in this situation: >>> data >> verb ( lambda : func ( ... )) In this case, func should be called as normal function. This function should return None UNC_ARG: It is an argument of any function call one: None of the above situation fits function should be only called inside register_*.wrapper function pipda.utils . evaluate_expr ( expr , data , context ) \u2192 any </> Evaluate a mixed expression function pipda.utils . has_expr ( expr ) \u2192 bool </> Check if expr has any Expression object in it function pipda.utils . functype ( func ) </> Check the type of the function Parameters func (callable) \u2014 A function Returns (str) The type of the function - verb: A verb that is registered by register_verb - func: A function that is registered by register_func , with data as the first argument - plain-func: A function that is registered by register_func , without data as the first argument - plain: A plain python function function pipda.utils . bind_arguments ( func , args , kwargs ) </> Try to bind arguments, instead of run the function to see if argumentscan fit the function Parameters func (callable) \u2014 The function args (tuple) \u2014 The positional arguments to bind to the function kwargs \u2014 The keyword arguments to bind to the function type_check \u2014 Whether do the type check for the values ignore_first \u2014 Whether ignore type check for the first argument ignore_types \u2014 Types to be ignored (always return True for any values) Raises TypeError \u2014 When arguments failed to bind or types of valuesdon't match argument type annotations if type_check is True. Returns (BoundArguments) inspect.BoundArguments","title":"pipda.utils"},{"location":"api/pipda.utils/#pipdautils","text":"</> Provide utilities Classes InaccessibleToNULLException \u2014 Raises when access to NULLClass object </> NULLClass \u2014 Sometimes, None is a valid option. In order to distinguish thissituation, NULL is used for a default. </> CallingEnvs \u2014 Types of piping/calling envs </> DataEnv \u2014 A data context that can be accessed by the function registered by pipda.register_* so that the data argument doesn't need to be passed when called </> Functions bind_arguments ( func , args , kwargs ) (BoundArguments) \u2014 Try to bind arguments, instead of run the function to see if argumentscan fit the function </> calling_env ( funtype ) (any) \u2014 Checking how the function is called: </> evaluate_expr ( expr , data , context ) (any) \u2014 Evaluate a mixed expression </> functype ( func ) (str) \u2014 Check the type of the function </> get_env_data ( frame ) (any) \u2014 Check and return if there is a data set in the context wherethe verb or function is called </> has_expr ( expr ) (bool) \u2014 Check if expr has any Expression object in it </> options_context ( **kwargs ) (generator(T_co, T_contra, V_co)) \u2014 A context manager to execute code with temporary options </> generator","title":"pipda.utils"},{"location":"api/pipda.utils/#pipdautilsoptions_context","text":"</> A context manager to execute code with temporary options class","title":"pipda.utils.options_context"},{"location":"api/pipda.utils/#pipdautilsinaccessibletonullexception","text":"</> Bases Exception BaseException Raises when access to NULLClass object class","title":"pipda.utils.InaccessibleToNULLException"},{"location":"api/pipda.utils/#pipdautilsnullclass","text":"</> Sometimes, None is a valid option. In order to distinguish thissituation, NULL is used for a default. It is also used as data to fast evaluate FastEvalFunction and FastEvalVerb objects. If failed, InaccessibleToNULLException will be raised. Methods __repr__ ( ) (str) \u2014 String representation </> method","title":"pipda.utils.NULLClass"},{"location":"api/pipda.utils/#pipdautilsnullclassrepr","text":"</> String representation class","title":"pipda.utils.NULLClass.repr"},{"location":"api/pipda.utils/#pipdautilscallingenvs","text":"</> Bases enum.Enum Types of piping/calling envs Classes EnumMeta \u2014 Metaclass for Enum </> class","title":"pipda.utils.CallingEnvs"},{"location":"api/pipda.utils/#enumenummeta","text":"</> Metaclass for Enum Attributes __members__ \u2014 Returns a mapping of member name->value. This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. </> Methods __bool__ ( ) \u2014 classes/types should always be True. </> __call__ ( cls , value , names , module , qualname , type , start ) \u2014 Either returns an existing member, or creates a new enum class. </> __dir__ ( ) \u2014 Specialized dir implementation for types. </> __getattr__ ( cls , name ) \u2014 Return the enum member matching name </> __iter__ ( cls ) \u2014 Returns members in definition order. </> __reversed__ ( cls ) \u2014 Returns members in reverse definition order. </> __setattr__ ( cls , name , value ) \u2014 Block attempts to reassign Enum members. </> method __bool__ ( ) </> classes/types should always be True. staticmethod __call__ ( cls , value , names=None , module=None , qualname=None , type=None , start=1 ) </> Either returns an existing member, or creates a new enum class. This method is used both when an enum class is given a value to match to an enumeration member (i.e. Color(3)) and for the functional API (i.e. Color = Enum('Color', names='RED GREEN BLUE')). When used for the functional API: value will be the name of the new class. names should be either a string of white-space/comma delimited names (values will start at start ), or an iterator/mapping of name, value pairs. module should be set to the module this class is being created in; if it is not set, an attempt to find that module will be made, but if it fails the class will not be picklable. qualname should be set to the actual location this class can be found at in its module; by default it is set to the global scope. If this is not correct, unpickling will fail in some circumstances. type , if set, will be mixed in as the first base class. method __dir__ ( ) </> Specialized dir implementation for types. staticmethod __getattr__ ( cls , name ) </> Return the enum member matching name We use getattr instead of descriptors or inserting into the enum class' dict in order to support name and value being both properties for enum members (which live in the class' dict ) and enum members themselves. staticmethod __iter__ ( cls ) </> Returns members in definition order. staticmethod __reversed__ ( cls ) </> Returns members in reverse definition order. staticmethod __setattr__ ( cls , name , value ) </> Block attempts to reassign Enum members. A simple assignment to the class namespace only changes one of the several possible ways to get an Enum member from the Enum class, resulting in an inconsistent Enumeration. class","title":"enum.EnumMeta"},{"location":"api/pipda.utils/#pipdautilsdataenv","text":"</> A data context that can be accessed by the function registered by pipda.register_* so that the data argument doesn't need to be passed when called Parameters data (any) \u2014 The data to be attached to the context Methods delete ( ) \u2014 Delete the attached data </> get ( ) (any) \u2014 Get the data </> set ( data ) \u2014 Update the data </> method","title":"pipda.utils.DataEnv"},{"location":"api/pipda.utils/#pipdautilsdataenvget","text":"</> Get the data method","title":"pipda.utils.DataEnv.get"},{"location":"api/pipda.utils/#pipdautilsdataenvset","text":"</> Update the data method","title":"pipda.utils.DataEnv.set"},{"location":"api/pipda.utils/#pipdautilsdataenvdelete","text":"</> Delete the attached data function","title":"pipda.utils.DataEnv.delete"},{"location":"api/pipda.utils/#pipdautilsget_env_data","text":"</> Check and return if there is a data set in the context wherethe verb or function is called The data has to be named as _ function","title":"pipda.utils.get_env_data"},{"location":"api/pipda.utils/#pipdautilscalling_env","text":"</> Checking how the function is called: PIPING_VERB: It is a verb that is piped directed. ie. data >> verb(...) PIPING: It is a function called as (part of) the argument of a piping verb. ie.: >>> data >> verb ( func ( ... )) Note that `func` here could also be a verb. When a function is called inside a lambda body, it should not be counted in this situation: >>> data >> verb ( lambda : func ( ... )) In this case, func should be called as normal function. This function should return None UNC_ARG: It is an argument of any function call one: None of the above situation fits function should be only called inside register_*.wrapper function","title":"pipda.utils.calling_env"},{"location":"api/pipda.utils/#pipdautilsevaluate_expr","text":"</> Evaluate a mixed expression function","title":"pipda.utils.evaluate_expr"},{"location":"api/pipda.utils/#pipdautilshas_expr","text":"</> Check if expr has any Expression object in it function","title":"pipda.utils.has_expr"},{"location":"api/pipda.utils/#pipdautilsfunctype","text":"</> Check the type of the function Parameters func (callable) \u2014 A function Returns (str) The type of the function - verb: A verb that is registered by register_verb - func: A function that is registered by register_func , with data as the first argument - plain-func: A function that is registered by register_func , without data as the first argument - plain: A plain python function function","title":"pipda.utils.functype"},{"location":"api/pipda.utils/#pipdautilsbind_arguments","text":"</> Try to bind arguments, instead of run the function to see if argumentscan fit the function Parameters func (callable) \u2014 The function args (tuple) \u2014 The positional arguments to bind to the function kwargs \u2014 The keyword arguments to bind to the function type_check \u2014 Whether do the type check for the values ignore_first \u2014 Whether ignore type check for the first argument ignore_types \u2014 Types to be ignored (always return True for any values) Raises TypeError \u2014 When arguments failed to bind or types of valuesdon't match argument type annotations if type_check is True. Returns (BoundArguments) inspect.BoundArguments","title":"pipda.utils.bind_arguments"},{"location":"api/pipda.verb/","text":"module pipda . verb </> Provide register_verb to register verbs Classes Verb \u2014 The verb class </> FastEvalVerb \u2014 Verbs that can use its first argument to evaluate </> class pipda.verb . Verb ( func , args , kwargs , dataarg=True ) </> Bases pipda.function.Function pipda.expression.Expression The verb class Parameters func (callable or Expression ) \u2014 The function to execute Attributes args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> _pipda_eval ( data , context ) (any) \u2014 Execute the function with the data </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method _pipda_eval ( data , context=None ) \u2192 any </> Execute the function with the data The context will be determined by the function itself, so the context argument will not be used, since it will not override the context of the function class pipda.verb . FastEvalVerb ( func , args , kwargs , dataarg=True ) </> Bases pipda.function.Function pipda.expression.Expression Verbs that can use its first argument to evaluate Parameters func (callable or Expression ) \u2014 The function to execute Attributes args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 Expression </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 Expression </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as indexes method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs","title":"pipda.verb"},{"location":"api/pipda.verb/#pipdaverb","text":"</> Provide register_verb to register verbs Classes Verb \u2014 The verb class </> FastEvalVerb \u2014 Verbs that can use its first argument to evaluate </> class","title":"pipda.verb"},{"location":"api/pipda.verb/#pipdaverbverb","text":"</> Bases pipda.function.Function pipda.expression.Expression The verb class Parameters func (callable or Expression ) \u2014 The function to execute Attributes args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> _pipda_eval ( data , context ) (any) \u2014 Execute the function with the data </> method","title":"pipda.verb.Verb"},{"location":"api/pipda.verb/#pipdaexpressionexpressionhash","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.verb/#pipdaexpressionexpressiongetattr","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.verb/#pipdaexpressionexpressiongetitem","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.verb/#pipdaexpressionexpressionindex","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.verb/#pipdaexpressionexpressioniter","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.verb/#pipdafunctionfunction_pipda_eval","text":"</> Execute the function with the data The context will be determined by the function itself, so the context argument will not be used, since it will not override the context of the function class","title":"pipda.function.Function._pipda_eval"},{"location":"api/pipda.verb/#pipdaverbfastevalverb","text":"</> Bases pipda.function.Function pipda.expression.Expression Verbs that can use its first argument to evaluate Parameters func (callable or Expression ) \u2014 The function to execute Attributes args \u2014 The arguments of the function context \u2014 The context dataarg \u2014 Whether the function has data as the first argument func \u2014 The function kwargs \u2014 The keyword arguments of the function Methods __getattr__ ( name ) ( Expression ) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) ( Expression ) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as indexes </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> method","title":"pipda.verb.FastEvalVerb"},{"location":"api/pipda.verb/#pipdaexpressionexpressionhash_1","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.verb/#pipdaexpressionexpressiongetattr_1","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.verb/#pipdaexpressionexpressiongetitem_1","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.verb/#pipdaexpressionexpressionindex_1","text":"</> Allow Expression object to work as indexes method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.verb/#pipdaexpressionexpressioniter_1","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs","title":"pipda.expression.Expression.iter"},{"location":"api/source/pipda.context/","text":"SOURCE CODE pipda. context DOCS \"\"\"Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when context is mixed, meaning *args is evaluated with select and **kwargs is evaluated with evaluation. 4. when it is unset, you will need to evaluate args and kwargs yourself. \"\"\" from abc import ABC , abstractmethod , abstractproperty from enum import Enum from typing import Any , ClassVar , Union class ContextError ( Exception ): DOCS \"\"\"Any errors related to contexts\"\"\" class ContextBase ( ABC ): # pragma: no cover DOCS \"\"\"The context abstract class, defining how the Reference objects are evaluated - `getattr` defines how `f.A` is evaluated. Note that `f.A.B` will always be evaluated as `getattr(f.A, 'B')` - `getitem` defines how `f[item]` is evaluated. Note that the `item` here is an evaluated value defined by `getref`. - `ref` here defines how the reference/item in `f.item` is evaluated. Since we could do `f[f.A]`. \"\"\" @abstractmethod DOCS def getattr ( self , parent : Any , ref : str , is_direct : bool = False ) -> Any : \"\"\"Defines how `f.A` is evaluated\"\"\" @abstractmethod DOCS def getitem ( self , parent : Any , ref : Any , is_direct : bool = False ) -> Any : \"\"\"Defines how `f[item]` is evaluated\"\"\" def __repr__ ( self ) -> str : return f \"< { self . __class__ . __name__ } @ { hex ( id ( self )) } >\" @property DOCS def ref ( self ) -> \"ContextBase\" : \"\"\"Defines how `item` in `f[item]` is evaluated. This function should return a `ContextBase` object.\"\"\" return self @property DOCS def args ( self ) -> \"ContextBase\" : \"\"\"The context to evaluate `*args` passed to a function\"\"\" return self @property DOCS def kwargs ( self ) -> \"ContextBase\" : \"\"\"The context to evaluate `**kwargs` passed to a function\"\"\" return self @abstractproperty DOCS def name ( self ) -> str : \"\"\"The name of the context\"\"\" class ContextSelect ( ContextBase ): DOCS \"\"\"Context used in a select context In this kind of context, - `f.A` works as a shortcut of `'A'`; - `f[ref]` works as a shortcut of `ref`. However, `ref` is needed to be evaluated by a context returned by `getref` \"\"\" name : ClassVar [ str ] = \"select\" def getattr ( self , parent : Any , ref : str , is_direct : bool = False ) -> str : DOCS \"\"\"Get the `ref` directly, regardless of `data`\"\"\" return ref def getitem ( self , parent : Any , ref : Any , is_direct : bool = False ) -> Any : DOCS \"\"\"Get the `ref` directly, which is already evaluated by `f[ref]`\"\"\" return ref class ContextEval ( ContextBase ): DOCS \"\"\"Context used in a data-evaluation context In this kind of context, the expression is evaluated as-is. That is, `f.A` is evaluated as `f.A` and `f[item]` is evaluated as `f[item]` \"\"\" name : ClassVar [ str ] = \"eval\" def getattr ( self , parent : Any , ref : str , is_direct : bool = False ) -> Any : DOCS \"\"\"How to evaluate `f.A`\"\"\" return getattr ( parent , ref ) def getitem ( self , parent : Any , ref : Any , is_direct : bool = False ) -> Any : DOCS \"\"\"How to evaluate `f[item]`\"\"\" return parent [ ref ] class ContextPending ( ContextBase ): DOCS \"\"\"Pending context\"\"\" name : ClassVar [ str ] = \"pending\" def getattr ( self , parent : Any , ref : str , is_direct : bool = False ) -> str : DOCS \"\"\"Get the `ref` directly, regardless of `data`\"\"\" raise NotImplementedError ( \"Pending context cannot be used to evaluate.\" ) def getitem ( self , parent : Any , ref : Any , is_direct : bool = False ) -> Any : DOCS \"\"\"Get the `ref` directly, which is already evaluated by `f[ref]`\"\"\" raise NotImplementedError ( \"Pending context cannot be used to evaluate.\" ) class ContextMixed ( ContextBase ): DOCS \"\"\"A mixed context, where the `*args` are evaluated with `ContextSelect` and `**args` are evaluated with `ContextEval`.\"\"\" name : ClassVar [ str ] = \"mixed\" def getattr ( self , parent : Any , ref : str , is_direct : bool = False ) -> None : DOCS raise NotImplementedError ( \"Mixed context should be used via `.args` or `.kwargs`\" ) def getitem ( self , parent : Any , ref : Any , is_direct : bool = False ) -> None : DOCS raise NotImplementedError ( \"Mixed context should be used via `.args` or `.kwargs`\" ) @property def args ( self ): return ContextSelect () @property def kwargs ( self ): return ContextEval () class Context ( Enum ): DOCS \"\"\"Context to solve f.A and f['A'] UNSET: The function's evaluation is dependent on it's parents PENDING: Context to leave the arguments to be evaluated inside the function SELECT: It select-based context EVAL: It evaluation-based context MIXED: Mixed context. For *args, used select-based; for **kwargs, use evaluation-based. \"\"\" UNSET = None PENDING = ContextPending () SELECT = ContextSelect () EVAL = ContextEval () MIXED = ContextMixed () ContextAnnoType = Union [ Context , ContextBase ]","title":"pipda.context"},{"location":"api/source/pipda.expression/","text":"SOURCE CODE pipda. expression DOCS \"\"\"Provides the abstract class Expression\"\"\" from abc import ABC , abstractmethod from functools import partialmethod from typing import Any from .context import ContextBase class Expression ( ABC ): DOCS \"\"\"The abstract Expression class\"\"\" def __hash__ ( self ) -> int : DOCS \"\"\"Make it hashable\"\"\" return hash ( id ( self )) def __getattr__ ( self , name : str ) -> \"Expression\" : DOCS \"\"\"Whenever `expr.attr` is encountered, return a ReferenceAttr object\"\"\" # for dispatch from .symbolic import ReferenceAttr return ReferenceAttr ( self , name ) def __getitem__ ( self , item : Any ) -> \"Expression\" : DOCS \"\"\"Whenever `expr[item]` is encountered, return a ReferenceAttr object\"\"\" from .symbolic import ReferenceItem return ReferenceItem ( self , item ) def _op_handler ( self , op : str , * args : Any , ** kwargs : Any ) -> \"Expression\" : \"\"\"Handle the operators\"\"\" from .operator import Operator return Operator . REGISTERED ( op , ( self , * args ), kwargs ) # Make sure the operators connect all expressions into one __add__ = partialmethod ( _op_handler , \"add\" ) __radd__ = partialmethod ( _op_handler , \"radd\" ) __sub__ = partialmethod ( _op_handler , \"sub\" ) __rsub__ = partialmethod ( _op_handler , \"rsub\" ) __mul__ = partialmethod ( _op_handler , \"mul\" ) __rmul__ = partialmethod ( _op_handler , \"rmul\" ) __matmul__ = partialmethod ( _op_handler , \"matmul\" ) __rmatmul__ = partialmethod ( _op_handler , \"rmatmul\" ) __truediv__ = partialmethod ( _op_handler , \"truediv\" ) __rtruediv__ = partialmethod ( _op_handler , \"rtruediv\" ) __floordiv__ = partialmethod ( _op_handler , \"floordiv\" ) __rfloordiv__ = partialmethod ( _op_handler , \"rfloordiv\" ) __mod__ = partialmethod ( _op_handler , \"mod\" ) __rmod__ = partialmethod ( _op_handler , \"rmod\" ) __lshift__ = partialmethod ( _op_handler , \"lshift\" ) __rlshift__ = partialmethod ( _op_handler , \"rlshift\" ) __rshift__ = partialmethod ( _op_handler , \"rshift\" ) __rrshift__ = partialmethod ( _op_handler , \"rrshift\" ) __and__ = partialmethod ( _op_handler , \"and_\" ) __rand__ = partialmethod ( _op_handler , \"rand_\" ) __xor__ = partialmethod ( _op_handler , \"xor\" ) __rxor__ = partialmethod ( _op_handler , \"rxor\" ) __or__ = partialmethod ( _op_handler , \"or_\" ) __ror__ = partialmethod ( _op_handler , \"ror_\" ) __pow__ = partialmethod ( _op_handler , \"pow\" ) __rpow__ = partialmethod ( _op_handler , \"rpow\" ) # __contains__() is forced into bool # __contains__ = partialmethod(_op_handler, 'contains') __lt__ = partialmethod ( _op_handler , \"lt\" ) # type: ignore __le__ = partialmethod ( _op_handler , \"le\" ) __eq__ = partialmethod ( _op_handler , \"eq\" ) # type: ignore __ne__ = partialmethod ( _op_handler , \"ne\" ) # type: ignore __gt__ = partialmethod ( _op_handler , \"gt\" ) __ge__ = partialmethod ( _op_handler , \"ge\" ) __neg__ = partialmethod ( _op_handler , \"neg\" ) __pos__ = partialmethod ( _op_handler , \"pos\" ) __invert__ = partialmethod ( _op_handler , \"invert\" ) # pylint: disable=bad-option-value,invalid-index-returned def __index__ ( self ): DOCS \"\"\"Allow Expression object to work as indexes\"\"\" return None def __iter__ ( self ): DOCS \"\"\"Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs \"\"\" raise TypeError ( \"Expression object is not iterable. \\n \" \"If you are expecting the evaluated results of the object, try \" \"using the piping syntax or writing it in a independent statement, \" \"instead of an argument of a regular function call.\" ) @abstractmethod def _pipda_eval ( self , data : Any , context : ContextBase = None , ) -> Any : \"\"\"Evaluate the expression using given data\"\"\"","title":"pipda.expression"},{"location":"api/source/pipda.function/","text":"SOURCE CODE pipda. function DOCS \"\"\"Provides register_func to register functions\"\"\" from typing import Any , Callable , Mapping , Tuple , Type , Union from .utils import ( NULL , InaccessibleToNULLException , bind_arguments , evaluate_expr , ) from .expression import Expression from .context import ContextBase , ContextError class Function ( Expression ): DOCS \"\"\"The Function class, defining how the function should be executed when needed Args: func: The function to execute context: The context to evaluate the Reference/Operator objects Attributes: func: The function context: The context args: The arguments of the function kwargs: The keyword arguments of the function dataarg: Whether the function has data as the first argument \"\"\" def __init__ ( self , func : Union [ Callable , Expression ], args : Tuple , kwargs : Mapping [ str , Any ], dataarg : bool = True , ) -> None : self . _pipda_func = func self . _pipda_args = args self . _pipda_kwargs = kwargs self . _pipda_dataarg = dataarg def __repr__ ( self ) -> str : if isinstance ( self . _pipda_func , Expression ): func = repr ( self . _pipda_func ) else : func = self . _pipda_func . __qualname__ return ( f \" { self . __class__ . __name__ } \" f \"(func= { func } , dataarg= { self . _pipda_dataarg } )\" ) def _pipda_eval ( self , data : Any , context : ContextBase = None ) -> Any : \"\"\"Execute the function with the data The context will be determined by the function itself, so the context argument will not be used, since it will not override the context of the function \"\"\" # don't change at 2nd evaluation # in case we have f.col.mean() func = self . _pipda_func if isinstance ( func , Expression ): func = evaluate_expr ( func , data , context ) dispatcher = _get_dispatcher ( func , type ( data )) # type: ignore func_context = getattr ( dispatcher , \"context\" , None ) func_extra_contexts = getattr ( dispatcher , \"extra_contexts\" , None ) context = func_context or context args = ( ( data , * self . _pipda_args ) if self . _pipda_dataarg else self . _pipda_args ) bondargs = bind_arguments ( dispatcher , args , self . _pipda_kwargs ) if func_extra_contexts : # evaluate some specfic args for key , ctx in func_extra_contexts . items (): if key not in bondargs . arguments : raise KeyError ( f \"[ { dispatcher . __qualname__ } ] No such argument: { key !r} \" ) bondargs . arguments [ key ] = evaluate_expr ( bondargs . arguments [ key ], data , ctx ) if \"_context\" in bondargs . arguments : bondargs . arguments [ \"_context\" ] = context if context and context . name == \"pending\" : # leave args/kwargs for the child # verb/function/operator to evaluate return func ( * bondargs . args , ** bondargs . kwargs ) # type: ignore args = evaluate_expr ( bondargs . args , data , context . args if context else context ) kwargs = evaluate_expr ( bondargs . kwargs , data , context . kwargs if context else context ) return func ( * args , ** kwargs ) # type: ignore class FastEvalFunction ( Function ): DOCS \"\"\"Fast evaluation function\"\"\" def _pipda_fast_eval ( self ): \"\"\"Evaluate this function\"\"\" try : return self . _pipda_eval ( NULL ) except ( ContextError , InaccessibleToNULLException , NotImplementedError ): return self # Helper functions -------------------------------- def _get_dispatcher ( func : Callable , typ : Type ) -> Callable : dispatch = getattr ( func , \"dispatch\" , None ) if dispatch is None : return func return dispatch ( typ )","title":"pipda.function"},{"location":"api/source/pipda/","text":"SOURCE CODE pipda DOCS \"\"\"A framework for data piping in python\"\"\" # pylint: disable=unused-import from .context import Context , ContextBase from .expression import Expression from .operator import Operator from .symbolic import Symbolic from .utils import DataEnv , evaluate_expr , functype , options , options_context from .register import ( register_func , register_operator , register_piping , register_verb , unregister , ) __version__ = \"0.4.5\"","title":"pipda"},{"location":"api/source/pipda.operator/","text":"SOURCE CODE pipda. operator DOCS \"\"\"Provide the Operator class\"\"\" import operator from enum import Enum from functools import wraps from typing import Any , Callable , Mapping , Tuple , ClassVar , Type from .context import ContextAnnoType , ContextBase from .function import Function class Operator ( Function ): DOCS \"\"\"Operator class, defining how the operators in verb/function arguments should be evaluated Args: op: The operator context: Should be None while initialization. It depends on the verb or the function that uses it as an argument args: The arguments of the operator kwargs: The keyword arguments of the operator datarg: Should be False. No data argument for the operator function. Attributes: REGISTERED: The registered Operator class. It's this class by default Use `register_operator` as a decorator to register a operator class \"\"\" REGISTERED : ClassVar [ Type [ \"Operator\" ]] = None def __init__ ( self , op : str , args : Tuple , kwargs : Mapping [ str , Any ], datarg : bool = False , ) -> None : self . op = op self . data = None op_func = self . _get_op_func () super () . __init__ ( op_func , args , kwargs , datarg ) @staticmethod DOCS def set_context ( context : ContextAnnoType , extra_contexts : Mapping [ str , ContextAnnoType ] = None , ) -> Callable [[ Callable ], Callable ]: \"\"\"Set custom context for a operator method\"\"\" def wrapper ( func ): func . context = ( context . value if isinstance ( context , Enum ) else context ) extra_contexts2 = extra_contexts or {} func . extra_contexts = { key : ctx . value if isinstance ( ctx , Enum ) else ctx for key , ctx in extra_contexts2 . items () } return func return wrapper def _pipda_eval ( self , data : Any , context : ContextBase = None ) -> Any : \"\"\"Evaluate the operator No data passed to the operator function. It should be used to evaluate the arguments. \"\"\" # set the context and data in case they need to be used # inside the function. self . data = data return super () . _pipda_eval ( data , context ) def _get_op_func ( self ) -> Callable : \"\"\"Get the operator function from the operator module by name\"\"\" def _opfunc ( opname : str ) -> Callable : self_op_name = f \"_op_ { opname } \" if hasattr ( self . __class__ , self_op_name ): return getattr ( self , self_op_name ) return getattr ( operator , opname , None ) op_func = _opfunc ( self . op ) if op_func : return op_func if self . op [ 0 ] == 'r' : # if we get radd, swap left and right operands op_func = _opfunc ( self . op [ 1 :]) if op_func : @wraps ( op_func ) def left_op_func ( arg_a , arg_b , * args , ** kwargs ): return op_func ( arg_b , arg_a , * args , ** kwargs ) return left_op_func raise ValueError ( f \"No operator function defined for { self . op !r} \" )","title":"pipda.operator"},{"location":"api/source/pipda.register/","text":"SOURCE CODE pipda. register DOCS \"\"\"Provide register_* suite\"\"\" import ast import sys import typing from collections import namedtuple from enum import Enum from functools import singledispatch , wraps from types import FunctionType from typing import ( Any , Callable , Iterable , Mapping , Optional , Tuple , Type , Union , ) from .context import ContextAnnoType , ContextBase from .operator import Operator from .utils import NULL , CallingEnvs , calling_env , get_env_data from .verb import Verb from ._calling import ( verb_calling_rule1 , verb_calling_rule2 , verb_calling_rule3 , verb_calling_rule4 , dfunc_calling_rule1 , dfunc_calling_rule2 , dfunc_calling_rule3 , ndfunc_calling_rule1 , ndfunc_calling_rule2 , ndfunc_calling_rule3 , ) if typing . TYPE_CHECKING : # pragma: no cover import inspect # The Sign tuple Sign = namedtuple ( \"Sign\" , [ \"method\" , \"token\" ]) # All supported signs # method is used to be attached to verbs # ast token class is used to check if the verb or function # is running in piping mode PIPING_SIGNS = { \"+\" : Sign ( \"__radd__\" , ast . Add ), \"-\" : Sign ( \"__rsub__\" , ast . Sub ), \"*\" : Sign ( \"__rmul__\" , ast . Mult ), \"@\" : Sign ( \"__rmatmul__\" , ast . MatMult ), \"/\" : Sign ( \"__rtruediv__\" , ast . Div ), \"//\" : Sign ( \"__rfloordiv__\" , ast . FloorDiv ), \"%\" : Sign ( \"__rmod__\" , ast . Mod ), \"**\" : Sign ( \"__rpow__\" , ast . Pow ), \"<<\" : Sign ( \"__rlshift__\" , ast . LShift ), \">>\" : Sign ( \"__rrshift__\" , ast . RShift ), \"&\" : Sign ( \"__rand__\" , ast . BitAnd ), \"^\" : Sign ( \"__rxor__\" , ast . BitXor ), \"|\" : Sign ( \"__ror__\" , ast . BitOr ), } def register_piping ( sign : str ) -> None : DOCS \"\"\"Register a piping sign for the verbs This actually attaches the `_pipda_eval` method to the method defined in `PIPING_SIGNS`. Args: sign: One of the signs in `PIPING_SIGNS` \"\"\" if sign not in PIPING_SIGNS : raise ValueError ( f \"Unsupported piping sign: { sign } \" ) if Verb . CURRENT_SIGN : current_sign = PIPING_SIGNS [ Verb . CURRENT_SIGN ] delattr ( Verb , current_sign . method ) Verb . CURRENT_SIGN = sign new_sign = PIPING_SIGNS [ sign ] setattr ( Verb , new_sign . method , Verb . _pipda_eval ) def register_verb ( DOCS types : Union [ FunctionType , Type , Iterable [ Type ]] = object , context : ContextAnnoType = None , func : Optional [ FunctionType ] = None , extra_contexts : Optional [ Mapping [ str , ContextAnnoType ]] = None , ** attrs : Any , ) -> Callable : \"\"\"Register a verb with specific types of data If `func` is not given (works like `register_verb(cls, context=...)`), it returns a function, works as a decorator. For example >>> @register_verb(DataFrame, context=Context.EVAL) >>> def verb(data, ...): >>> ... When function is passed as a non-keyword argument, other arguments are as defaults >>> @register_verb >>> def verb(data, ...): >>> ... In such a case, it is like a generic function to work with all types of data. Verb calling rules 1. data >> verb(...) First argument should not be passed, using the data 2. data >> other_verb(verb(...)) First argument used, and a Function object will be returned from the verb. `f` represents the data, instead of the first argument of the verb. 3. verb(...) Called independently. The verb will be called regularly anyway. The first argument will be used as data to evaluate the arguments if there are any Expression objects 4. verb(...) with DataEnv First argument should not be passed in, will use the DataEnv's data to evaluate the arguments Args: types: The types of data for the verb Multiple types are supported to be passed as a list/tuple/set. It cannot be None for verbs. context: The context to evaluate the Expression objects func: The function to be decorated if passed explicitly extra_contexts: Extra contexts (if not the same as `context`) for specific arguments **attrs: Other attributes to be attached to the function Returns: A decorator function if `func` is not given or a wrapper function like a singledispatch generic function that can register other types, show all registry and dispatch for a specific type \"\"\" types , context , func , extra_contexts = _clean_register_args ( types , context , func , extra_contexts ) if func is None : return lambda fun : register_verb ( types , context , fun , extra_contexts , ** attrs ) if types is None : raise ValueError ( \"Verbs must be registered with data argument \" \"(`types` cannot be None)\" ) for name , attr in attrs . items (): setattr ( func , name , attr ) # allow register to have different context func . context = context func . extra_contexts = extra_contexts generic = _generalizing ( func , types ) return _wrapping_verb ( generic ) def register_func ( DOCS types : Union [ FunctionType , Type , Iterable [ Type ]] = object , context : Optional [ ContextAnnoType ] = None , func : Optional [ FunctionType ] = None , verb_arg_only : bool = False , extra_contexts : Optional [ Mapping [ str , ContextAnnoType ]] = None , ** attrs : Any , ) -> Callable : \"\"\"Register a function to be used in verb If `func` is not given (works like `register_verb(cls, context=...)`), it returns a function, works as a decorator. For example >>> @register_func(numpy.ndarray, context=Context.EVAL) >>> def func(data, ...): >>> ... When function is passed as a non-keyword argument, other arguments are as defaults >>> @register_func >>> def func(data, ...): >>> ... In such a case, it is like a generic function to work with all types of data. `data` is not a required argument. If not required, `cls` should be specified as `None`. Data function calling rules 1. data >> verb(func(...)) First argument is not used. Will use data 2. func(...) Called independently. The function will be called regularly anyway. Similar as Verb calling rule, but first argument will not be used for evaluation 3. func(...) with DataEnv First argument not used, passed implicitly with DataEnv. Non-data function calling rules: 1. data >> verb(func(...)) Return a Function object waiting for evaluation 2. func(...) Called regularly anyway 3. func(...) with DataEnv Evaluate with DataEnv. For example: mean(f.x) Args: types: The classes of data for the verb Multiple classes are supported to be passed as a list/tuple/set. None means no data argument for the function context: The context to evaluate the Expression objects func: The function to be decorated if passed explicitly verb_arg_only: Whether the function should be only used as an argument of a verb. This means it only works in the format of >>> data >> verb(..., func(...), ...) Note that even this won't work >>> verb(data, ..., func(...), ...) extra_contexts: Extra contexts (if not the same as `context`) for specific arguments **attrs: Other attributes to be attached to the function Returns: A decorator function if `func` is not given or a wrapper function like a singledispatch generic function that can register other types, show all registry and dispatch for a specific type \"\"\" types , context , func , extra_contexts = _clean_register_args ( types , context , func , extra_contexts ) if func is None : return lambda fun : register_func ( types , context , fun , verb_arg_only , extra_contexts , ** attrs ) for name , attr in attrs . items (): setattr ( func , name , attr ) # allow register to have different context func . context = context func . extra_contexts = extra_contexts if types is None : return _register_ndfunc ( func , verb_arg_only ) return _register_dfunc ( types , func , verb_arg_only ) def register_operator ( op_class : Type [ Operator ]) -> Type [ Operator ]: DOCS \"\"\"Register an Operator class Working as a decorator for a class subclassed from Operator. Args: op_class: The operator class Returns: The decorated operator class \"\"\" if not issubclass ( op_class , Operator ): raise ValueError ( \"The operator class to be registered must be \" \"a subclass of pipda.Operator.\" ) Operator . REGISTERED = op_class return op_class def unregister ( func : Callable ) -> Callable : DOCS \"\"\"Get the original function before register Args: func: The function that is either registered by `register_verb` or `register_func` Returns: The original function that before register \"\"\" origfunc = getattr ( func , \"__origfunc__\" , None ) if origfunc is None : raise ValueError ( f \"Function is not registered with pipda: { func } \" ) return origfunc # Helper functions -------------------------------- def _clean_register_args ( types : Optional [ Union [ FunctionType , Type , Iterable [ Type ]]], context : Optional [ ContextAnnoType ], func : Optional [ Callable ], extra_contexts : Optional [ Mapping [ str , ContextAnnoType ]], ) -> Tuple [ Optional [ Iterable [ Type ]], Optional [ ContextBase ], Optional [ Callable ], Optional [ Mapping [ str , ContextBase ]], ]: \"\"\"Clean up the register_* arguments and get the right order\"\"\" if func is None and isinstance ( types , FunctionType ): func , types = types , object if types is not None and not isinstance ( types , ( tuple , set , list )): types = ( types ,) # type: ignore if isinstance ( context , Enum ): context = context . value extra_contexts = extra_contexts or {} extra_contexts = { key : ctx . value if isinstance ( ctx , Enum ) else ctx for key , ctx in extra_contexts . items () } return types , context , func , extra_contexts # type: ignore def _generalizing ( func : Callable , types : Iterable [ Type ]) -> Callable : \"\"\"Returns the generic function and register the types\"\"\" if object in types : generic = singledispatch ( func ) else : # have to define this function here, so that every time a new function # is generated. # Otherwise, singledispatch mixed the registry when registering the # same function @wraps ( func ) def _not_implemented ( _data : Any , * args : Any , ** kwargs : Any ) -> None : raise NotImplementedError ( f \" { func . __qualname__ !r} is not \" f \"registered for type: { type ( _data ) } .\" ) _not_implemented . __name__ = \"_not_implemented\" # __name__ is used to tell if object is allowed _not_implemented . context = func . context _not_implemented . extra_contexts = func . extra_contexts generic = singledispatch ( _not_implemented ) for typ in types : if typ is not object : generic . register ( typ , func ) generic . __origfunc__ = func return generic def _wrapping_verb ( generic : Callable ) -> Callable : \"\"\"Wrapping the generic function with data argument This basically defines how to run the function \"\"\" @wraps ( generic . __origfunc__ ) # type: ignore def wrapper ( * args : Any , __calling_env : Optional [ CallingEnvs ] = None , __envdata : Any = NULL , ** kwargs : Any , ) -> Any : \"\"\"The wrapper that eventually runs Args: *args: and **kwargs: The arguments passed to the original function __calling_env: The calling environment. Mostly used for debugging Will detect from the AST. __envdata: The environment data for evaluating the Expression object \"\"\" call_env = __calling_env or calling_env ( 'Verb' ) envdata = NULL if call_env is CallingEnvs . PIPING_VERB : calling_rule = verb_calling_rule1 elif call_env is CallingEnvs . PIPING : calling_rule = verb_calling_rule2 else : envdata = ( __envdata if __envdata is not NULL else get_env_data ( sys . _getframe ( 1 )) ) calling_rule = ( verb_calling_rule3 if envdata is NULL else verb_calling_rule4 ) return calling_rule ( generic , args , kwargs , envdata ) wrapper . register = _singledispatch_register ( generic ) wrapper . registry = generic . registry wrapper . dispatch = generic . dispatch wrapper . __pipda__ = \"Verb\" wrapper . __origfunc__ = generic . __origfunc__ return wrapper def _wrapping_dfunc ( generic : Callable , verb_arg_only : Optional [ bool ] = None ) -> Callable : \"\"\"Wrapping the generic function with data argument This basically defines how to run the function \"\"\" @wraps ( generic . __origfunc__ ) # type: ignore def wrapper ( * args : Any , __calling_env : Optional [ CallingEnvs ] = None , __envdata : Any = NULL , ** kwargs : Any , ) -> Any : \"\"\"The wrapper that eventually runs Args: *args: and **kwargs: The arguments passed to the original function __calling_env: The calling environment. Mostly used for debugging Will detect from the AST. __envdata: The environment data for evaluating the Expression object \"\"\" call_env = __calling_env or calling_env ( 'Function' ) if call_env is CallingEnvs . PIPING : calling_rule = dfunc_calling_rule1 envdata = NULL else : envdata = ( __envdata if __envdata is not NULL else get_env_data ( sys . _getframe ( 1 )) ) calling_rule = ( dfunc_calling_rule2 if envdata is NULL else dfunc_calling_rule3 ) return calling_rule ( generic , args , kwargs , envdata , verb_arg_only ) wrapper . register = _singledispatch_register ( generic ) wrapper . registry = generic . registry wrapper . dispatch = generic . dispatch wrapper . __pipda__ = \"Function\" wrapper . __origfunc__ = generic . __origfunc__ return wrapper def _wrapping_ndfunc ( generic : Callable , verb_arg_only : Optional [ bool ] = None ) -> Callable : \"\"\"Wrapping the generic function without data argument\"\"\" @wraps ( generic ) # type: ignore def wrapper ( * args : Any , __calling_env : Any = None , __envdata : Any = NULL , # could be None ** kwargs : Any , ) -> Any : call_env = __calling_env or calling_env ( 'PlainFunction' ) # As argument of a verb if call_env is CallingEnvs . PIPING : calling_rule = ndfunc_calling_rule1 envdata = NULL else : envdata = ( __envdata if __envdata is not NULL else get_env_data ( sys . _getframe ( 1 )) ) calling_rule = ( ndfunc_calling_rule2 if envdata is NULL else ndfunc_calling_rule3 ) return calling_rule ( generic , args , kwargs , envdata , verb_arg_only ) wrapper . __pipda__ = \"PlainFunction\" wrapper . __origfunc__ = generic return wrapper def _singledispatch_register ( generic : Callable , ) -> Callable [[ Union [ Type , Iterable [ Type ]], Any , Optional [ Callable ]], Callable ]: \"\"\"Allow register of generic function to register types with context\"\"\" def _register_func ( types : Union [ Type , Iterable [ Type ]], context : Optional [ ContextAnnoType ] = None , func : Optional [ Callable ] = None , # extra_contexts? ) -> Callable : types , context , func , _ = _clean_register_args ( types , context , func , None ) if func is None : return lambda fun : _register_func ( types , context , fun ) func . context = context out = func for typ in types : out = generic . register ( typ , out ) # don't use functools.wraps() as it will override func.context out . __name__ = generic . __origfunc__ . __name__ out . __qualname__ = generic . __origfunc__ . __qualname__ out . __doc__ = generic . __origfunc__ . __doc__ return out return _register_func def _register_ndfunc ( func : Callable , verb_arg_only : bool ) -> Callable : \"\"\"Register functions without data as the first argument\"\"\" return _wrapping_ndfunc ( func , verb_arg_only ) def _register_dfunc ( types : Iterable [ Type ], func : Callable , verb_arg_only : bool ) -> Callable : \"\"\"Register functions with data as the first argument\"\"\" generic = _generalizing ( func , types ) return _wrapping_dfunc ( generic , verb_arg_only ) register_piping ( \">>\" ) register_operator ( Operator )","title":"pipda.register"},{"location":"api/source/pipda.symbolic/","text":"SOURCE CODE pipda. symbolic DOCS \"\"\"Provides Symbolic and Reference classes\"\"\" from abc import ABC , abstractmethod from typing import ClassVar , Any from varname import varname from .utils import evaluate_expr from .context import ContextBase , ContextError from .expression import Expression from .function import Function class Reference ( Expression , ABC ): DOCS \"\"\"The Reference class, used to define how it should be evaluated according to the context for references, for example, `f.A`, `f['A']` or the references of them (i.e. `f.A.B`, `f.A['b']`, etc) Args: parent: The parent of this reference. For example: `f.A` for `f.A.B` ref: The reference. For example: `B` for `f.A.B` context: Defaults to `None`, which should not be specified while instansiation. Because these types of expressions are independent. A context should be passed to `evaluate` to evaluate the expression. \"\"\" def __init__ ( self , parent : Any , ref : Any ) -> None : self . _pipda_parent = parent self . _pipda_ref = ref def __repr__ ( self ) -> str : return ( f \" { self . __class__ . __name__ } (\" f \"parent= { self . _pipda_parent !r} , ref= { self . _pipda_ref !r} )\" ) def __call__ ( self , * args , ** kwargs ): DOCS \"\"\"Allow `f.a.b` to be a function, so that one can do `f.a.b(1)`\"\"\" return Function ( self , args , kwargs , False ) @abstractmethod def _pipda_eval ( self , data : Any , context : ContextBase = None ) -> Any : \"\"\"Evaluate the reference according to the context\"\"\" if context is None : # needs context to be evaluated raise ContextError ( f \"Cannot evaluate { repr ( self ) } \" \"object without a context.\" ) class ReferenceAttr ( Reference ): DOCS \"\"\"Attribute references, for example: `f.A`, `f.A.B` etc.\"\"\" # Whether it's a direct reference _pipda_direct : ClassVar [ bool ] = False def _pipda_eval ( self , data : Any , context : ContextBase = None ) -> Any : \"\"\"Evaluate the attribute references\"\"\" # if we don't have a context here, assuming that # we are calling `f.a.b(1)`, instead of evaluation super () . _pipda_eval ( data , context ) parent = evaluate_expr ( self . _pipda_parent , data , context ) return context . getattr ( parent , self . _pipda_ref , self . __class__ . _pipda_direct ) class ReferenceItem ( Reference ): DOCS \"\"\"Subscript references, for example: `f['A']`, `f.A['B']` etc\"\"\" _pipda_direct : ClassVar [ bool ] = False def _pipda_eval ( self , data : Any , context : ContextBase = None ) -> Any : \"\"\"Evaluate the subscript references\"\"\" super () . _pipda_eval ( data , context ) parent = evaluate_expr ( self . _pipda_parent , data , context ) ref = evaluate_expr ( self . _pipda_ref , data , context . ref ) return context . getitem ( parent , ref , self . __class__ . _pipda_direct ) class DirectRefAttr ( ReferenceAttr ): DOCS \"\"\"The direct attribute reference, such as `f.A`\"\"\" _pipda_direct : ClassVar [ bool ] = True class DirectRefItem ( ReferenceItem ): DOCS \"\"\"The direct attribute reference, such as `f['A']`\"\"\" _pipda_direct : ClassVar [ bool ] = True class Symbolic ( Expression ): DOCS \"\"\"The symbolic class, works as a proxy to represent the data In most cases it is used to construct the Reference objects. \"\"\" def __init__ ( self , name : str = None ): \"\"\"Construct a Symbolic object\"\"\" self . __name = name or varname ( raise_exc = False ) or 'f' def __getattr__ ( self , name : str ) -> Any : DOCS \"\"\"Create a DirectRefAttr object\"\"\" return DirectRefAttr ( self , name ) def __getitem__ ( self , item : Any ) -> Any : DOCS \"\"\"Create a DirectRefItem object\"\"\" return DirectRefItem ( self , item ) def __repr__ ( self ) -> str : return f \"<Symbolic: { self . __name } >\" def _pipda_eval ( self , data : Any , context : ContextBase = None ) -> Any : \"\"\"When evaluated, this should just return the data directly\"\"\" return data","title":"pipda.symbolic"},{"location":"api/source/pipda.utils/","text":"SOURCE CODE pipda. utils DOCS \"\"\"Provide utilities\"\"\" import ast import inspect import sys import warnings from contextlib import contextmanager from enum import Enum , auto from functools import lru_cache , singledispatch from types import FrameType from typing import Any , Callable , Generator , Mapping , Tuple from diot import Diot from executing import Source from pure_eval import CannotEval , Evaluator from .context import ContextAnnoType DATA_CONTEXTVAR_NAME = \"__pipda_context_data__\" options = Diot ( # Warn about failure to get ast node warn_astnode_failure = True , # All piping mode: # - Assume all verbs are using PIPING_VERB env # - Assume all data functions are using PIPING env # - Assume all non-data functions are using PIPING verbs # This is useful when source code is not available. assume_all_piping = False , ) @contextmanager DOCS def options_context ( ** kwargs : Mapping [ str , Any ]) -> Generator : \"\"\"A context manager to execute code with temporary options\"\"\" tmp_opts = options . copy () options . update ( ** kwargs ) yield options . update ( tmp_opts ) class InaccessibleToNULLException ( Exception ): DOCS \"\"\"Raises when access to NULLClass object\"\"\" class NULLClass : DOCS \"\"\"Sometimes, None is a valid option. In order to distinguish this situation, NULL is used for a default. It is also used as data to fast evaluate FastEvalFunction and FastEvalVerb objects. If failed, InaccessibleToNULLException will be raised. \"\"\" def __repr__ ( self ) -> str : DOCS \"\"\"String representation\"\"\" return \"NULL\" def _inaccessible ( self , * args : Any , ** kwargs : Any ) -> Any : raise InaccessibleToNULLException __bool__ = _inaccessible __len__ = _inaccessible __getitem__ = _inaccessible __getattr__ = _inaccessible # more ? NULL = NULLClass () class CallingEnvs ( Enum ): DOCS \"\"\"Types of piping/calling envs\"\"\" # When a function works as an argument of a verb calling # data >> verb(func()) # ^^^^^^ # Or # verb(data, func()) # ^^^^^^ PIPING = auto () # When I am the verb in piping syntax # data >> verb(...) # ^^^^^^^^^ PIPING_VERB = auto () # # When I am an argument of any function not in a piping syntax # # func(x=func2()) # # ^^^^^^^ # FUNC_ARG = auto() # Used to pass to the functions manually REGULAR = auto () class DataEnv : DOCS \"\"\"A data context that can be accessed by the function registered by `pipda.register_*` so that the data argument doesn't need to be passed when called Args: data: The data to be attached to the context \"\"\" def __init__ ( self , data : Any , name : str = DATA_CONTEXTVAR_NAME ) -> None : self . name = name self . data = data def get ( self ) -> Any : DOCS \"\"\"Get the data\"\"\" return self . data def set ( self , data : Any ) -> None : DOCS \"\"\"Update the data\"\"\" self . data = data def delete ( self ) -> None : DOCS \"\"\"Delete the attached data\"\"\" self . set ( NULL ) def get_env_data ( frame : FrameType ) -> Any : DOCS \"\"\"Check and return if there is a data set in the context where the verb or function is called The data has to be named as `_` \"\"\" envdata = frame . f_locals . get ( \"_\" , None ) if not isinstance ( envdata , DataEnv ) or envdata . name != DATA_CONTEXTVAR_NAME : return NULL return envdata . get () def calling_env ( funtype : str ) -> Any : DOCS \"\"\"Checking how the function is called: 1. PIPING_VERB: It is a verb that is piped directed. ie. data >> verb(...) 2. PIPING: It is a function called as (part of) the argument of a piping verb. ie.: >>> data >> verb(func(...)) Note that `func` here could also be a verb. When a function is called inside a lambda body, it should not be counted in this situation: >>> data >> verb(lambda: func(...)) In this case, func should be called as normal function. This function should return `None` 3. FUNC_ARG: It is an argument of any function call 4. None: None of the above situation fits This function should be only called inside register_*.wrapper \"\"\" if options . assume_all_piping : return ( CallingEnvs . PIPING_VERB if funtype == 'Verb' else CallingEnvs . PIPING ) # frame 1: register_*.wrapper # frame 2: func(...) frame = sys . _getframe ( 2 ) my_node = Source . executing ( frame ) . node if not my_node and options . warn_astnode_failure : warnings . warn ( \"Failed to fetch the node calling the function, \" \"call it with the original function.\" ) return None piping_verb_node = _get_piping_verb_node ( my_node ) if piping_verb_node is my_node and piping_verb_node is not None : return CallingEnvs . PIPING_VERB if _is_piping_verb_argument_node ( my_node , piping_verb_node ): return CallingEnvs . PIPING parent_call_node = _argument_node_of ( my_node ) if parent_call_node is None : return None # check if parent call node is a function registered by # register_verb/register_func evaluator = Evaluator . from_frame ( frame ) try : func = evaluator [ parent_call_node . func ] except CannotEval : # pragma: no cover return None if functype ( func ) != \"plain\" : return CallingEnvs . PIPING return None def evaluate_expr ( expr : Any , data : Any , context : ContextAnnoType ) -> Any : DOCS \"\"\"Evaluate a mixed expression\"\"\" if isinstance ( context , Enum ): context = context . value if hasattr ( expr . __class__ , \"_pipda_eval\" ): # Not only for Expression objects, but also # allow customized classes return expr . _pipda_eval ( data , context ) if isinstance ( expr , ( tuple , list , set )): # In case it's subclass return expr . __class__ ( ( evaluate_expr ( elem , data , context ) for elem in expr ) ) if isinstance ( expr , slice ): return slice ( evaluate_expr ( expr . start , data , context ), evaluate_expr ( expr . stop , data , context ), evaluate_expr ( expr . step , data , context ), ) if isinstance ( expr , dict ): return expr . __class__ ( { key : evaluate_expr ( val , data , context ) for key , val in expr . items () } ) return expr @singledispatch DOCS def has_expr ( expr : Any ) -> bool : \"\"\"Check if expr has any Expression object in it\"\"\" from .expression import Expression return isinstance ( expr , Expression ) @has_expr . register ( tuple ) @has_expr . register ( list ) @has_expr . register ( set ) def _ ( expr : Any ) -> Any : return any ( has_expr ( elem ) for elem in expr ) @has_expr . register ( slice ) def _ ( expr : Any ) -> Any : return has_expr (( expr . start , expr . stop , expr . step )) @has_expr . register ( dict ) def _ ( expr : Any ) -> Any : return any ( has_expr ( elem ) for elem in expr . values ()) def functype ( func : Callable ) -> str : DOCS \"\"\"Check the type of the function Args: func: A function Returns: The type of the function - verb: A verb that is registered by `register_verb` - func: A function that is registered by `register_func`, with data as the first argument - plain-func: A function that is registered by `register_func`, without data as the first argument - plain: A plain python function \"\"\" pipda_type = getattr ( func , \"__pipda__\" , None ) if pipda_type == \"Verb\" : return \"verb\" if pipda_type == \"Function\" : return \"func\" if pipda_type == \"PlainFunction\" : return \"plain-func\" return \"plain\" def bind_arguments ( DOCS func : Callable , args : Tuple , kwargs : Mapping [ str , Any ], # type_check: bool = False, # ignore_first: bool = False, # ignore_types: Tuple[Type] = (Expression, ) ) -> inspect . BoundArguments : \"\"\"Try to bind arguments, instead of run the function to see if arguments can fit the function Args: func: The function args: The positional arguments to bind to the function kwargs: The keyword arguments to bind to the function type_check: Whether do the type check for the values ignore_first: Whether ignore type check for the first argument ignore_types: Types to be ignored (always return True for any values) Raises: TypeError: When arguments failed to bind or types of values don't match argument type annotations if `type_check` is True. Returns: inspect.BoundArguments \"\"\" signature = inspect . signature ( func ) try : boundargs = signature . bind ( * args , ** kwargs ) except TypeError as terr : raise TypeError ( f \"[ { func . __qualname__ } ] { terr } \" ) from None # if len(boundargs.arguments) > 0 and type_check: # # some arguments bound # firstarg = list(signature.parameters)[0] # for key, val in boundargs.arguments.items(): # if ignore_first and key == firstarg: # continue # annotation = signature.parameters[key].annotation # if annotation is inspect._empty: # continue # if not instanceof(val, annotation, ignore=ignore_types): # raise TypeError( # f\"[{func.__qualname__}] Argument `{key}` expect a value \" # f\"of {annotation}, got {val}\" # ) boundargs . apply_defaults () return boundargs # Helper functions ----------------------------- @lru_cache () def _get_piping_verb_node ( calling_node : ast . Call ) -> ast . Call : \"\"\"Get the ast node that is ensured the piping verb call Args: calling_node: Current Call node Returns: The verb call node if found, otherwise None \"\"\" from .register import PIPING_SIGNS from .verb import Verb # check if we have the piping node (i.e. >>) child = calling_node parent = getattr ( child , \"parent\" , None ) token = PIPING_SIGNS [ Verb . CURRENT_SIGN ] . token while parent : if ( # data >> verb(...) ( isinstance ( parent , ast . BinOp ) and parent . right is child ) or # data >>= verb(...) ( isinstance ( parent , ast . AugAssign ) and parent . value is child ) ) and isinstance ( parent . op , token ): return child child = parent parent = getattr ( parent , \"parent\" , None ) return None @lru_cache () def _is_piping_verb_argument_node ( sub_node : ast . Call , verb_node : ast . Call ) -> bool : \"\"\"Check if node func() is an argument of verb() (i.e. verb(func()))\"\"\" if not verb_node : return False parent = sub_node while parent : if isinstance ( parent , ast . Call ) and ( parent is verb_node or _argument_node_of ( parent ) is verb_node ): return True if isinstance ( parent , ast . Lambda ): # function inside lambda is not in a piping environment return False parent = getattr ( parent , \"parent\" , None ) # when verb_node is ensured, we can anyway retrieve it as the parent of # sub_node return False # pragma: no cover @lru_cache () def _argument_node_of ( sub_node : ast . Call ) -> ast . Call : \"\"\"Get the Call node of a argument subnode\"\"\" parent = getattr ( sub_node , \"parent\" , None ) while parent : if isinstance ( parent , ast . Call ) and ( sub_node in parent . args or sub_node in parent . keywords ): return parent if isinstance ( parent , ast . Lambda ): # function inside lambda is not in a piping environment return None sub_node = parent parent = getattr ( parent , \"parent\" , None ) return None","title":"pipda.utils"},{"location":"api/source/pipda.verb/","text":"SOURCE CODE pipda. verb DOCS \"\"\"Provide register_verb to register verbs\"\"\" import typing from .utils import has_expr from .function import Function class Verb ( Function ): DOCS \"\"\"The verb class\"\"\" CURRENT_SIGN : typing . ClassVar [ str ] = \"\" class FastEvalVerb ( Function ): DOCS \"\"\"Verbs that can use its first argument to evaluate\"\"\" def _pipda_fast_eval ( self ): \"\"\"Evaluate this verb function using the first argument\"\"\" if not self . _pipda_args : return self firstarg , args = self . _pipda_args [ 0 ], self . _pipda_args [ 1 :] if isinstance ( firstarg , FastEvalVerb ): firstarg = firstarg . _pipda_fast_eval () if has_expr ( firstarg ): # if first argument is not data # copy self? self . _pipda_dataarg = False return self return Function ( self . _pipda_func , args , self . _pipda_kwargs ) . _pipda_eval ( firstarg )","title":"pipda.verb"}]}